# Status Report: web-routing-configuration
Timestamp: 2025-12-27
Scope: topic/web-routing-configuration
Confidence: FRESH
Git Commit: 00b1065

## Executive Summary

**Overall: 5% complete | Critical issues: 0 | Tests reliable: N/A (no tests for this feature)**

This feature aims to allow users to configure provider routing (subagent mappings) from the web dashboard instead of manually editing `config.yaml`. Currently, the system is READ-ONLY - configuration is loaded at startup from `config.yaml` and cannot be modified at runtime.

## What Exists

### Backend (Proxy)

| Component | Status | Evidence |
|-----------|--------|----------|
| `config.go` - Config loading | COMPLETE | Loads YAML at startup, supports providers + subagent mappings |
| `model_router.go` - Routing logic | COMPLETE | Routes requests based on subagent system prompts |
| `handlers.go` - Stats endpoints | COMPLETE | `/api/stats/subagents` returns current routing stats |
| Config modification API | NOT_STARTED | No endpoints exist for config updates |
| Hot reload mechanism | NOT_STARTED | Config only loaded once at startup |

**Key files:**
- `/Users/bmf/code/brandon-fryslie_claude-code-proxy/proxy/internal/config/config.go` (234 lines)
- `/Users/bmf/code/brandon-fryslie_claude-code-proxy/proxy/internal/service/model_router.go` (293 lines)
- `/Users/bmf/code/brandon-fryslie_claude-code-proxy/proxy/internal/handler/handlers.go` (984 lines)

### Frontend (Dashboard)

| Component | Status | Evidence |
|-----------|--------|----------|
| `Routing.tsx` - Display page | COMPLETE | Shows subagent stats, read-only |
| `Settings.tsx` - Dashboard settings | COMPLETE | Client-side only (localStorage) |
| `api.ts` - API client | PARTIAL | Has `useSubagentStats`, no mutation hooks |
| Config editing UI | NOT_STARTED | No forms for editing provider/subagent mappings |

**Key files:**
- `/Users/bmf/code/brandon-fryslie_claude-code-proxy/dashboard/src/pages/Routing.tsx` (177 lines)
- `/Users/bmf/code/brandon-fryslie_claude-code-proxy/dashboard/src/pages/Settings.tsx` (206 lines)
- `/Users/bmf/code/brandon-fryslie_claude-code-proxy/dashboard/src/lib/api.ts` (219 lines)

### Configuration Structure (from `config.yaml.example`)

```yaml
providers:
  <name>:
    base_url: "..."
    api_key: "..."      # optional
    format: "anthropic" | "openai"  # required

subagents:
  enable: true|false
  mappings:
    <agent-name>: "<provider>:<model>"
```

## What's Missing

### 1. Configuration API Endpoints (Backend)

**Required endpoints:**

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/api/config` | GET | Return current configuration (sanitized - no API keys) |
| `/api/config/providers` | GET | List all providers |
| `/api/config/providers` | POST | Add new provider |
| `/api/config/providers/{name}` | PUT | Update provider |
| `/api/config/providers/{name}` | DELETE | Remove provider |
| `/api/config/subagents` | GET | Get subagent mappings |
| `/api/config/subagents` | PUT | Update subagent mappings |
| `/api/config/subagents/enable` | PUT | Toggle subagent routing |

**Implementation location:** `proxy/internal/handler/handlers.go`

### 2. Configuration Persistence (Backend)

**Current state:** Config loaded from YAML at startup, never written back.

**Required:**
- `config.Save()` method in `config.go` to write back to YAML
- Decision: Write to original file or separate file?
- Handle concurrent access (mutex around config operations)

### 3. Hot Reload Mechanism (Backend)

**Current state:** `ModelRouter` holds config reference, created once at startup.

**Required:**
- Signal to `ModelRouter` when config changes
- Reload custom agent prompts from `.claude/agents/` files
- Rebuild provider map if providers change
- Decision: Full restart vs. in-memory reload?

### 4. Frontend Configuration UI

**Required components:**

| Component | Purpose |
|-----------|---------|
| `ProviderList` | List all configured providers |
| `ProviderForm` | Add/edit provider (base_url, api_key, format) |
| `SubagentMappings` | Edit subagent -> provider:model mappings |
| `RoutingToggle` | Enable/disable subagent routing |

**API hooks needed:**
- `useConfig()` - fetch current config
- `useUpdateProvider()` - mutation for provider CRUD
- `useUpdateSubagents()` - mutation for subagent mappings

### 5. Missing Tests

| Area | Required Tests |
|------|----------------|
| Backend | Config API endpoints, YAML write/read roundtrip |
| Backend | Hot reload mechanism, concurrent access |
| Frontend | Provider form validation, subagent form |

## Dependencies and Risks

### Technical Dependencies

1. **YAML serialization** - Go's `gopkg.in/yaml.v3` already used, should handle write
2. **File permissions** - Proxy needs write access to `config.yaml`
3. **Config file location** - Currently searched in multiple locations; need consistent path

### Risks

| Risk | Severity | Mitigation |
|------|----------|------------|
| **File write permissions** | HIGH | Check permissions on startup, graceful error |
| **Corrupted config** | HIGH | Backup before write, validate before save |
| **Race conditions** | MEDIUM | Mutex around config read/write operations |
| **API key exposure** | HIGH | Never return API keys in GET responses |
| **Provider removal while in use** | MEDIUM | Warn if provider has active mappings |
| **Invalid config on restart** | HIGH | Validate config before writing to disk |

### Security Considerations

1. **API keys must NEVER be returned in API responses**
   - GET endpoints should mask/omit API keys
   - Only accept API keys on POST/PUT, never echo them back

2. **Authentication for config changes**
   - Currently: No authentication on any endpoint
   - Decision needed: Add auth for config endpoints only? Or all endpoints?

3. **CORS considerations**
   - Currently: `*` allowed (permissive)
   - Config endpoints may need stricter CORS

## Ambiguities Requiring Clarification

### 1. Persistence Strategy

**Question:** Where should runtime config changes be persisted?

**Options:**
| Option | Pros | Cons |
|--------|------|------|
| A. Original `config.yaml` | Single source of truth | Overwrites user's file, loses comments |
| B. Separate `config.runtime.yaml` | Preserves original file | Two files to manage, precedence confusion |
| C. SQLite database | Already have DB, atomic writes | Diverges from file-based config pattern |

**Impact:** Affects user workflow, backup strategy, and error recovery.

### 2. Hot Reload vs. Restart

**Question:** How should config changes take effect?

**Options:**
| Option | Pros | Cons |
|--------|------|------|
| A. Hot reload in memory | No downtime, immediate effect | Complex, potential inconsistent state |
| B. Require restart | Simple, atomic | Downtime, user annoyance |
| C. Soft reload (reinitialize components) | Balanced approach | Need to ensure clean state |

**Impact:** Affects complexity and user experience significantly.

### 3. Authentication for Config Changes

**Question:** Should config modification require authentication?

**Options:**
| Option | Pros | Cons |
|--------|------|------|
| A. No auth | Simple, consistent with current approach | Security risk if exposed |
| B. Simple token/password | Prevents casual access | Token management overhead |
| C. Full auth system | Proper security | Significant scope increase |

**Impact:** This is a local development tool - does it need auth?

### 4. Provider Testing Before Save

**Question:** Should the UI validate provider configuration before saving?

**Options:**
- Test API connectivity before save
- Save without validation
- Save with warning if test fails

**Impact:** Affects UX and prevents broken configs.

### 5. Subagent File Handling

**Question:** What happens when subagent routing is configured but agent file doesn't exist?

**Current behavior:** Warning logged, routing skipped for that agent.

**Should config UI:**
- Show warning in UI?
- Allow saving anyway?
- Provide file path guidance?

## Recommendations

### Priority Order

1. **Backend: Config read API** (LOW complexity)
   - Add `/api/config` endpoint returning sanitized config
   - Minimal risk, enables frontend development

2. **Frontend: Display current config** (LOW complexity)
   - Show providers and subagent mappings in Routing page
   - Read-only initially, enables UX iteration

3. **Backend: Config write with validation** (MEDIUM complexity)
   - Add config mutation endpoints
   - Include backup/restore mechanism
   - Requires decision on persistence strategy

4. **Backend: Hot reload** (MEDIUM-HIGH complexity)
   - Signal mechanism for config changes
   - Reinitialize `ModelRouter` with new config
   - Requires decision on reload strategy

5. **Frontend: Config editing UI** (MEDIUM complexity)
   - Provider CRUD forms
   - Subagent mapping editor
   - Validation and error handling

6. **Security: Basic auth for config endpoints** (OPTIONAL)
   - Only if deployment requires it

## Verdict

- [x] CONTINUE - Architecture is clear, no blocking ambiguities

**Rationale:** While there are open questions about persistence strategy and hot reload approach, these can be resolved during implementation. The recommended approach:

1. Start with **Option A** for persistence (original config.yaml) - simplest, matches user expectations
2. Start with **Option C** for reload (soft reload) - balance of simplicity and UX
3. Skip auth initially - this is a local dev tool

### Immediate Next Steps

1. Create `/api/config` GET endpoint returning sanitized config
2. Add `Providers` section to `Routing.tsx` showing configured providers
3. Decide on persistence strategy (recommend: original file with backup)

---

## Files to Modify

| File | Changes |
|------|---------|
| `proxy/internal/handler/handlers.go` | Add config CRUD handlers |
| `proxy/internal/config/config.go` | Add `Save()` method |
| `proxy/cmd/proxy/main.go` | Register new routes |
| `dashboard/src/pages/Routing.tsx` | Add provider display, eventually editing |
| `dashboard/src/lib/api.ts` | Add config mutation hooks |
| `dashboard/src/lib/types.ts` | Add config types |
