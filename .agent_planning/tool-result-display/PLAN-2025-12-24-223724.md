# Sprint Plan: Tool Result Display

**Generated**: 2025-12-24-223724
**Source**: STATUS-20251224.md (dashboard-parity evaluation)
**Epic**: brandon-fryslie_claude-code-proxy-k6y
**Sprint Goal**: Implement rich tool result rendering that formats output based on content type (code, JSON, text), detects code from Read tool, and handles errors gracefully with visual indicators.

---

## Executive Summary

**Current State** (from STATUS-20251224.md):
- New dashboard displays tool results as raw JSON in request details
- Missing dedicated ToolResult component that old dashboard has (256 LOC)
- No intelligent content type detection (code vs JSON vs text)
- No special handling for Read tool results (cat -n format parsing)
- No error state visualization for failed tool executions

**Target State** (from web/app/components/ToolResult.tsx):
- Auto-detect content type: code, JSON, or text
- Parse cat -n output from Read tool (line numbers → clean code)
- Render code with syntax highlighting via CodeViewer component
- Display success/error state with color-coded styling
- Show tool result ID and metadata
- Expandable for large content (>500 chars)
- Raw data structure view for debugging

**Gap**: New dashboard needs a complete ToolResult component to match old dashboard's intelligent result formatting.

---

## Scope

### In Scope
- Create ToolResult component in `dashboard/src/components/`
- Parse tool result content from `AnthropicContentBlock` type (type: "tool_result")
- Auto-detect content type (code, JSON, text) with heuristics
- Extract code from Read tool cat -n format (line numbers like "1→")
- Display success results with green theme, errors with red theme
- Render code content via CodeViewer component integration
- Render JSON content in formatted pre blocks
- Render text content with line breaks preserved
- Handle large content with expand/collapse (>500 char threshold)
- Show raw data structure as collapsible details
- Integrate with MessageContent component in Requests page

### Out of Scope
- CodeViewer component (separate epic: code-viewer-highlighting)
- Syntax highlighting implementation (handled by CodeViewer)
- Backend changes to tool result logging
- Tool execution time tracking
- Tool result comparison/diff

### Deferred
- Tool result search/filtering
- Tool result export functionality
- Advanced code parsing beyond cat -n format
- Custom formatters for specific tool types

---

## Work Items

### [P0] Create Base ToolResult Component

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: None
**Spec Reference**: web/app/components/ToolResult.tsx • **Status Reference**: STATUS-20251224.md §2.2 (Advanced Features)

#### Description
Create the core ToolResult component that renders tool execution results with success/error states, expandable content, and metadata display.

#### Acceptance Criteria
- [ ] Component renders success results with green gradient theme (emerald/green)
- [ ] Component renders error results with red gradient theme (red/pink)
- [ ] Component displays tool result ID in header if provided
- [ ] Component shows content type badge (Code, JSON, Text)
- [ ] Component shows character count for non-code content
- [ ] Component displays success/error indicator with status dot
- [ ] Component has expand/collapse for large content (>500 chars)
- [ ] Unit tests cover success and error states

#### Technical Notes
- Use lucide-react icons: CheckCircle, AlertCircle, Database, FileText, Clock
- Success gradient: `bg-gradient-to-r from-emerald-50 to-green-50`, border `border-emerald-200`
- Error gradient: `bg-gradient-to-r from-red-50 to-pink-50`, border `border-red-200`
- Props: `{ content: any, toolId?: string, isError?: boolean }`
- Component handles content structures: string, object with .text, object with .content, array

---

### [P0] Implement Content Type Detection

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: Create Base ToolResult Component
**Spec Reference**: ToolResult.tsx lines 15-44, 102-107 • **Status Reference**: STATUS-20251224.md §2.2

#### Description
Implement intelligent content type detection using heuristics to classify results as code, JSON, or text. Detects code based on patterns, line numbers, and structure.

#### Acceptance Criteria
- [ ] Detects code by checking for cat -n line numbers (pattern: `^\s*\d+→`)
- [ ] Detects code by checking for code patterns (function, const, import, class, etc.)
- [ ] Detects code by checking for file extensions in content
- [ ] Detects JSON by checking for isComplexObject or string starting with '{'
- [ ] Falls back to text for other content types
- [ ] isCodeContent() returns boolean based on heuristics
- [ ] Content type badge displays correct type (Code, JSON, Text)
- [ ] Unit tests verify all detection patterns

#### Technical Notes
- Code patterns to check: function, const, let, var, import, export, class, interface, type, def, if, for, while, curly braces
- Line number pattern: `/^\s*\d+→/m` (multiline regex)
- File extension pattern: `/\.(js|jsx|ts|tsx|py|rb|go|rs|java|cpp|c|h|cs|php|swift|kt|scala|r|sh|bash|sql|html|css|json|yaml|yml|toml|md|xml)$/m`
- Require code to have >100 chars AND code patterns (avoids false positives)

---

### [P0] Implement cat -n Format Parser

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: Implement Content Type Detection
**Spec Reference**: ToolResult.tsx lines 46-64 • **Status Reference**: STATUS-20251224.md §2.2

#### Description
Parse cat -n output format from Read tool results, extracting clean code by removing line numbers. Preserves original content if not cat -n format.

#### Acceptance Criteria
- [ ] Detects cat -n format by checking for line number pattern (`^\s*\d+→`)
- [ ] Extracts code by removing line numbers from each line
- [ ] Preserves original line content after arrow (→) character
- [ ] Returns unchanged content if not cat -n format
- [ ] extractCodeFromCatN() returns { code: string, fileName?: string }
- [ ] Handles edge cases (empty lines, malformed line numbers)
- [ ] Unit tests verify parsing with sample cat -n output

#### Technical Notes
- Line number format: `"     1→const foo = 'bar'"` → extract `"const foo = 'bar'"`
- Regex match: `/^\s*\d+→(.*)$/` captures everything after arrow
- Split content by newlines, process each line, join back
- Non-cat -n content passes through unchanged
- fileName extraction not implemented in MVP (return undefined)

---

### [P0] Implement Content Structure Handling

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Create Base ToolResult Component
**Spec Reference**: ToolResult.tsx lines 66-95 • **Status Reference**: STATUS-20251224.md §2.2

#### Description
Handle different tool result content structures (string, object with .text, object with .content, array) and normalize to displayable string.

#### Acceptance Criteria
- [ ] Returns content directly if type is string
- [ ] Returns content.text if object has 'text' property
- [ ] Returns content.content if object has 'content' property
- [ ] Joins array items with newlines using formatValue()
- [ ] Returns formatJSON() for complex objects
- [ ] Falls back to formatValue() for primitives
- [ ] getDisplayContent() handles all content structures
- [ ] Unit tests verify all structure types

#### Technical Notes
- Check structures in order: string → .text → .content → array → object → fallback
- Use formatValue() and formatJSON() utilities (from utils/formatters)
- Complex object check: `isComplexObject(content)`
- Array join: `content.map(item => formatValue(item)).join('\n')`

---

### [P1] Integrate CodeViewer for Code Content

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Implement cat -n Format Parser, CodeViewer component available
**Spec Reference**: ToolResult.tsx lines 202-203 • **Status Reference**: STATUS-20251224.md §2.2

#### Description
Integrate CodeViewer component to render code content with syntax highlighting when content type is detected as code.

#### Acceptance Criteria
- [ ] Renders CodeViewer when isCode === true
- [ ] Passes extracted code to CodeViewer (cleaned from cat -n format)
- [ ] Passes fileName if available (currently undefined in MVP)
- [ ] Falls back to pre block if CodeViewer unavailable
- [ ] Does not show character count for code content (shown by CodeViewer)
- [ ] Unit tests verify CodeViewer integration
- [ ] Integration tests verify code rendering in full request view

#### Technical Notes
- CodeViewer expected at `../components/CodeViewer` (from code-viewer epic)
- Usage: `<CodeViewer code={extractedCode} fileName={content.fileName} />`
- CodeViewer handles syntax highlighting and language detection
- Conditional render: `{isCode ? <CodeViewer .../> : <pre>...</pre>}`

---

### [P0] Implement JSON and Text Rendering

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Implement Content Type Detection
**Spec Reference**: ToolResult.tsx lines 204-214 • **Status Reference**: STATUS-20251224.md §2.2

#### Description
Render JSON content in formatted monospace pre blocks and text content with preserved line breaks and HTML entities.

#### Acceptance Criteria
- [ ] JSON content renders in gray pre block with monospace font
- [ ] JSON uses formatted JSON string (truncated if shouldTruncate)
- [ ] Text content renders with line breaks preserved (replace \n with <br>)
- [ ] Text content uses dangerouslySetInnerHTML for HTML rendering
- [ ] Text content breaks long words (break-words class)
- [ ] Text content has relaxed leading for readability
- [ ] Unit tests verify JSON and text rendering
- [ ] Unit tests verify truncation behavior

#### Technical Notes
- JSON block: `<pre className="text-sm text-gray-700 whitespace-pre-wrap font-mono overflow-x-auto bg-gray-50 rounded-lg p-3 border border-gray-200">`
- Text rendering: `dangerouslySetInnerHTML={{ __html: truncatedContent.replace(/\n/g, '<br>') }}`
- Use truncateText() utility for large content (>500 chars)
- Show "Show full content" button when truncated

---

### [P1] Implement Large Content Handling

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Create Base ToolResult Component
**Spec Reference**: ToolResult.tsx lines 98-101, 217-226 • **Status Reference**: STATUS-20251224.md §2.2

#### Description
Add expand/collapse functionality for large content (>500 characters) with truncation preview and "Show full content" button.

#### Acceptance Criteria
- [ ] Detects large content (displayContent.length > 500)
- [ ] Truncates content to 500 chars when not expanded
- [ ] Shows truncated content in collapsed state
- [ ] Shows full content in expanded state
- [ ] Displays "Show full content (N characters)" button when truncated
- [ ] Button updates state to expand content
- [ ] Does not truncate code content (handled by CodeViewer)
- [ ] Unit tests verify truncation and expansion

#### Technical Notes
- Truncation threshold: 500 characters
- Use truncateText() utility: `truncateText(displayContent, 500)`
- State: `const [isExpanded, setIsExpanded] = useState(false)`
- Conditional: `const shouldTruncate = isLargeContent && !isExpanded`
- Expand button: `<button onClick={() => setIsExpanded(true)}>Show full content (...)</button>`

---

### [P1] Add Raw Data Structure View

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Create Base ToolResult Component
**Spec Reference**: ToolResult.tsx lines 232-246 • **Status Reference**: STATUS-20251224.md §2.2

#### Description
Add collapsible details section that shows raw JSON structure of content object for debugging and inspection.

#### Acceptance Criteria
- [ ] Shows raw data details if content is object with >1 property
- [ ] Uses collapsible <details> element
- [ ] Summary text: "Show raw data structure"
- [ ] Displays formatted JSON in monospace pre block
- [ ] Uses formatJSON() utility for formatting
- [ ] Chevron icon rotates on expand (group-open:rotate-90)
- [ ] Unit tests verify details rendering and toggle

#### Technical Notes
- Conditional: `{content && typeof content === 'object' && Object.keys(content).length > 1 && ...}`
- Details pattern: `<details className="cursor-pointer group"><summary>...</summary>...</details>`
- Icon rotation: `<ChevronRight className="w-3 h-3 group-open:rotate-90 transition-transform" />`
- JSON display: `<pre className="text-xs overflow-x-auto font-mono text-gray-700 bg-gray-50 rounded p-2">{formatJSON(content)}</pre>`

---

### [P0] Integrate ToolResult with MessageContent

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Create Base ToolResult Component
**Spec Reference**: web/app/components/MessageContent.tsx lines 81-90 • **Status Reference**: STATUS-20251224.md §2.2

#### Description
Update MessageContent component to use new ToolResult component when rendering content blocks of type "tool_result". Ensures tool results appear in request detail view.

#### Acceptance Criteria
- [ ] MessageContent imports ToolResult component
- [ ] MessageContent renders ToolResult for content.type === 'tool_result'
- [ ] Passes content (text or content property) to ToolResult
- [ ] Passes tool_call_id or id as toolId prop
- [ ] Passes is_error flag to isError prop
- [ ] Handles missing properties gracefully (defaults to false for isError)
- [ ] Integration tests verify tool_result rendering in full request view
- [ ] Tool results appear correctly in Requests page detail panel

#### Technical Notes
- MessageContent location: `dashboard/src/components/MessageContent.tsx` (create if missing)
- Content block type from AnthropicContentBlock: `{ type: 'tool_result', text?: string, content?: any, tool_call_id?: string, is_error?: boolean }`
- Pattern: `case 'tool_result': const resultContent = content.text || content.content || content; return <ToolResult content={resultContent} toolId={content.tool_call_id || content.id} isError={content.is_error || false} />`

---

## Dependencies

### Component Dependencies
```
ToolResult Component
├── formatters (formatValue, formatJSON, isComplexObject, truncateText)
├── CodeViewer (for code content) - from code-viewer epic
└── lucide-react icons (CheckCircle, AlertCircle, etc.)

MessageContent Component
└── ToolResult Component
```

### Data Flow
```
AnthropicRequest (backend)
└── messages[].content[] (AnthropicContentBlock)
    └── { type: 'tool_result', content, tool_call_id, is_error }
        └── <ToolResult> component
            ├── Detect content type (code/JSON/text)
            ├── Parse cat -n format (if code)
            └── Render with CodeViewer or pre block
```

---

## Recommended Sprint Planning

### Sprint Breakdown (1 sprint = 1 week)

**Week 1: Core ToolResult Component**
1. Create Base ToolResult Component (P0)
2. Implement Content Type Detection (P0)
3. Implement cat -n Format Parser (P0)
4. Implement Content Structure Handling (P0)

**Week 2: Rendering and Integration**
5. Implement JSON and Text Rendering (P0)
6. Implement Large Content Handling (P1)
7. Add Raw Data Structure View (P1)
8. Integrate CodeViewer for Code Content (P1) - requires CodeViewer from other sprint
9. Integrate ToolResult with MessageContent (P0)

**Parallel Work**: CodeViewer component from code-viewer-highlighting epic can be developed in parallel.

---

## Risk Assessment

### High Risk
- **CodeViewer Dependency**: Code content rendering blocked until CodeViewer component exists
  - **Mitigation**: Develop CodeViewer in parallel sprint, or use basic pre block fallback initially

### Medium Risk
- **Formatter Utilities Missing**: New dashboard may not have formatValue, formatJSON, truncateText helpers
  - **Mitigation**: Port from old dashboard utils/formatters.ts or recreate minimal versions

- **cat -n Format Variations**: Read tool output format might vary across different file types or errors
  - **Mitigation**: Add robust regex matching, fall back to original content if parsing fails

### Low Risk
- **Content Structure Variations**: Tool results might have unexpected structures
  - **Mitigation**: Comprehensive structure handling with fallbacks in getDisplayContent()

---

## Testing Strategy

### Unit Tests
- ToolResult component rendering (success state, error state)
- Content type detection (code, JSON, text)
- cat -n format parsing (valid format, malformed, non-cat -n)
- Content structure handling (string, object variations, array)
- Large content truncation and expansion
- Raw data details toggle

### Integration Tests
- MessageContent → ToolResult integration
- ToolResult → CodeViewer integration (code content)
- Full request view with mixed tool results

### Manual Testing
- Verify tool results render correctly in Requests page
- Test with real Read tool results (cat -n format)
- Test with real error results (API failures)
- Test expand/collapse for large JSON responses
- Verify syntax highlighting appears for code content

---

## Definition of Done

See DOD-2025-12-24-223724.md for detailed acceptance criteria.

**Sprint Complete When**:
- ✅ All P0 work items completed and tested
- ✅ All P1 work items completed and tested
- ✅ Tool results visible in new dashboard Requests page
- ✅ Code content renders with syntax highlighting (via CodeViewer)
- ✅ JSON and text content render correctly
- ✅ Error results show red theme
- ✅ Unit tests passing (>80% coverage)
- ✅ Integration tests passing
- ✅ Manual testing verified on real request data

---

## Blockers and Questions

### Blockers
None currently - all dependencies can be created within this sprint or stubbed.

### Questions
1. **Formatter Utilities**: Does new dashboard have formatValue/formatJSON/truncateText utilities? If not, should we port from old dashboard?
2. **CodeViewer Timeline**: When will CodeViewer component be ready? Should we use basic pre blocks initially?
3. **cat -n Format**: Are there variations in Read tool output format we need to handle (different OS, file types)?
4. **Content Type Detection**: Should we add more heuristics for specific languages (e.g., SQL, shell scripts)?

---

## Success Metrics

- **Feature Parity**: Tool results match old dashboard visualization quality
- **Code Detection**: >95% accuracy detecting code vs text vs JSON
- **cat -n Parsing**: 100% success parsing Read tool output
- **Error Handling**: Clear visual distinction between success and error results
- **Performance**: No lag when rendering large tool results
- **Code Quality**: Components are reusable, well-tested, maintainable
