# Implementation Context: Phase 4 Priority Features

**Generated:** 2026-01-09
**Purpose:** Comprehensive context for agents implementing this plan

---

## Project Architecture

### Backend (Go)

**Split Service Architecture:**
- `proxy-core` (port 3001) - Lightweight API proxy for `/v1/messages`
- `proxy-data` (port 3002) - Dashboard APIs, stats, indexing
- Caddy (port 3000) - Reverse proxy routing

**Key Files:**

| File | Purpose | LOC |
|------|---------|-----|
| `proxy/internal/config/config.go` | YAML config loading, validation | 234 |
| `proxy/internal/handler/data_handler.go` | proxy-data handlers (/api/*) | ~300 |
| `proxy/internal/handler/core_handler.go` | proxy-core handlers | ~200 |
| `proxy/internal/service/model_router.go` | Subagent detection/routing | 293 |
| `proxy/internal/provider/openai.go` | OpenAI format conversion | ~400 |
| `proxy/internal/provider/anthropic.go` | Anthropic API forwarding | ~200 |

**Config Structure (config.go:35-85):**
```go
type Config struct {
    Server    ServerConfig              `yaml:"server"`
    Providers map[string]ProviderConfig `yaml:"providers"`
    Storage   StorageConfig             `yaml:"storage"`
    Subagents SubagentsConfig           `yaml:"subagents"`
}

type ProviderConfig struct {
    Format     string `yaml:"format"`     // "anthropic" or "openai"
    APIKey     string `yaml:"api_key"`
    BaseURL    string `yaml:"base_url"`
    Version    string `yaml:"version"`
    MaxRetries int    `yaml:"max_retries"`
}

type SubagentsConfig struct {
    Enable   bool              `yaml:"enable"`
    Mappings map[string]string `yaml:"mappings"` // agent_name -> "provider:model"
}
```

**Existing Handler Pattern (data_handler.go):**
```go
func (h *DataHandler) GetStats(w http.ResponseWriter, r *http.Request) {
    stats, err := h.storage.GetStats(r.Context())
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    json.NewEncoder(w).Encode(stats)
}
```

### Frontend (React/TypeScript)

**Tech Stack:**
- React 18 + TypeScript
- TanStack Query for data fetching
- TanStack Router for routing
- Tailwind CSS
- Vite for bundling

**Key Files:**

| File | Purpose | LOC |
|------|---------|-----|
| `dashboard/src/pages/Routing.tsx` | Routing stats display | 177 |
| `dashboard/src/pages/Requests.tsx` | Request list | ~250 |
| `dashboard/src/pages/Settings.tsx` | Settings placeholder | 67 |
| `dashboard/src/lib/api.ts` | API hooks | ~200 |
| `dashboard/src/lib/types.ts` | TypeScript types | ~150 |

**API Hook Pattern (api.ts):**
```typescript
export function useStats() {
  return useQuery({
    queryKey: ['stats'],
    queryFn: () => fetchAPI<Stats>('/api/stats'),
    staleTime: 60 * 1000,
  })
}
```

**Query Client Setup (main.tsx):**
```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30 * 1000,
      refetchOnWindowFocus: false,
    },
  },
})
```

---

## Deliverable 1: Web Routing Config Implementation

### Backend Changes

**New Handlers in data_handler.go:**

Add these handlers after existing stats handlers (~line 150):

```go
// GetConfig returns the full sanitized configuration
func (h *DataHandler) GetConfig(w http.ResponseWriter, r *http.Request) {
    sanitized := h.config.Sanitize()
    json.NewEncoder(w).Encode(sanitized)
}

// GetProviders returns sanitized provider configs
func (h *DataHandler) GetProviders(w http.ResponseWriter, r *http.Request) {
    sanitized := make(map[string]ProviderConfig)
    for name, provider := range h.config.Providers {
        sanitized[name] = provider.Sanitize()
    }
    json.NewEncoder(w).Encode(sanitized)
}

// GetSubagents returns subagent configuration
func (h *DataHandler) GetSubagents(w http.ResponseWriter, r *http.Request) {
    json.NewEncoder(w).Encode(h.config.Subagents)
}
```

**Sanitization Method in config.go:**

Add after `ProviderConfig` struct (~line 55):

```go
func (p ProviderConfig) Sanitize() ProviderConfig {
    sanitized := p
    if p.APIKey != "" {
        sanitized.APIKey = "***REDACTED***"
    }
    return sanitized
}

func (c *Config) Sanitize() Config {
    sanitized := *c
    sanitized.Providers = make(map[string]ProviderConfig)
    for name, provider := range c.Providers {
        sanitized.Providers[name] = provider.Sanitize()
    }
    return sanitized
}
```

**Route Registration in proxy-data/main.go:**

Add routes (~line 80, near other /api routes):

```go
mux.HandleFunc("GET /api/config", dataHandler.GetConfig)
mux.HandleFunc("GET /api/config/providers", dataHandler.GetProviders)
mux.HandleFunc("GET /api/config/subagents", dataHandler.GetSubagents)
```

### Frontend Changes

**Types in types.ts:**

Add after existing types:

```typescript
export interface ProviderConfig {
  format: 'anthropic' | 'openai'
  base_url: string
  api_key?: string  // Redacted or omitted
  version?: string
  max_retries?: number
}

export interface SubagentsConfig {
  enable: boolean
  mappings: Record<string, string>  // agent_name -> "provider:model"
}

export interface Config {
  server: {
    port: number
    host: string
  }
  providers: Record<string, ProviderConfig>
  subagents: SubagentsConfig
}
```

**Hooks in api.ts:**

Add after existing hooks:

```typescript
export function useConfig() {
  return useQuery({
    queryKey: ['config'],
    queryFn: () => fetchAPI<Config>('/api/config'),
    staleTime: 60 * 1000,
  })
}

export function useProviders() {
  return useQuery({
    queryKey: ['config', 'providers'],
    queryFn: () => fetchAPI<Record<string, ProviderConfig>>('/api/config/providers'),
    staleTime: 60 * 1000,
  })
}

export function useSubagentConfig() {
  return useQuery({
    queryKey: ['config', 'subagents'],
    queryFn: () => fetchAPI<SubagentsConfig>('/api/config/subagents'),
    staleTime: 60 * 1000,
  })
}
```

**Routing.tsx Enhancement:**

Current structure (line 1-50):
```typescript
export function RoutingPage() {
  const { data: stats } = useSubagentStats()
  // ... displays Active Routes table
}
```

Add sections before Active Routes table (~line 30):

```typescript
export function RoutingPage() {
  const { data: providers, isLoading: providersLoading } = useProviders()
  const { data: subagentConfig, isLoading: subagentLoading } = useSubagentConfig()
  const { data: stats } = useSubagentStats()

  return (
    <div className="space-y-6">
      {/* Providers Section */}
      <section>
        <h2 className="text-lg font-semibold mb-4">Providers</h2>
        {providersLoading ? (
          <div>Loading...</div>
        ) : (
          <div className="grid gap-4">
            {Object.entries(providers || {}).map(([name, config]) => (
              <ProviderCard key={name} name={name} config={config} />
            ))}
          </div>
        )}
      </section>

      {/* Subagent Mappings Section */}
      <section>
        <h2 className="text-lg font-semibold mb-4">
          Subagent Routing
          <span className={cn(
            "ml-2 px-2 py-1 text-xs rounded",
            subagentConfig?.enable ? "bg-green-100 text-green-800" : "bg-gray-100 text-gray-600"
          )}>
            {subagentConfig?.enable ? "Enabled" : "Disabled"}
          </span>
        </h2>
        <SubagentMappingsTable mappings={subagentConfig?.mappings || {}} />
      </section>

      {/* Existing Active Routes Section */}
      ...
    </div>
  )
}
```

---

## Deliverable 2: Data Management Implementation

### RefreshButton Component

Create `dashboard/src/components/RefreshButton.tsx`:

```typescript
import { RefreshCw } from 'lucide-react'
import { useQueryClient } from '@tanstack/react-query'
import { useState } from 'react'

interface RefreshButtonProps {
  queryKeys: string[][]
  onRefreshComplete?: () => void
}

export function RefreshButton({ queryKeys, onRefreshComplete }: RefreshButtonProps) {
  const queryClient = useQueryClient()
  const [isRefreshing, setIsRefreshing] = useState(false)

  const handleRefresh = async () => {
    if (isRefreshing) return
    setIsRefreshing(true)

    try {
      await Promise.all(
        queryKeys.map(key => queryClient.invalidateQueries({ queryKey: key }))
      )
      onRefreshComplete?.()
    } finally {
      setIsRefreshing(false)
    }
  }

  return (
    <button
      onClick={handleRefresh}
      disabled={isRefreshing}
      className="p-2 hover:bg-gray-100 rounded disabled:opacity-50"
    >
      <RefreshCw className={cn("h-4 w-4", isRefreshing && "animate-spin")} />
    </button>
  )
}
```

### ConfirmDeleteModal Component

Create `dashboard/src/components/ConfirmDeleteModal.tsx`:

```typescript
import { useState } from 'react'

interface ConfirmDeleteModalProps {
  isOpen: boolean
  onClose: () => void
  onConfirm: () => Promise<void>
  requestCount?: number
}

export function ConfirmDeleteModal({ isOpen, onClose, onConfirm, requestCount }: ConfirmDeleteModalProps) {
  const [confirmText, setConfirmText] = useState('')
  const [isDeleting, setIsDeleting] = useState(false)

  const handleConfirm = async () => {
    if (confirmText !== 'DELETE') return
    setIsDeleting(true)
    try {
      await onConfirm()
      onClose()
    } finally {
      setIsDeleting(false)
    }
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center">
      <div className="bg-white p-6 rounded-lg max-w-md">
        <h2 className="text-xl font-bold text-red-600">Clear All Requests?</h2>
        <p className="mt-2">
          This will permanently delete {requestCount?.toLocaleString() ?? 'all'} requests.
          This action cannot be undone.
        </p>
        <p className="mt-4">Type <strong>DELETE</strong> to confirm:</p>
        <input
          value={confirmText}
          onChange={e => setConfirmText(e.target.value)}
          className="mt-2 w-full border rounded px-3 py-2"
          placeholder="DELETE"
        />
        <div className="mt-4 flex gap-2">
          <button onClick={onClose} className="px-4 py-2 border rounded">
            Cancel
          </button>
          <button
            onClick={handleConfirm}
            disabled={confirmText !== 'DELETE' || isDeleting}
            className="px-4 py-2 bg-red-600 text-white rounded disabled:opacity-50"
          >
            {isDeleting ? 'Deleting...' : 'Confirm Delete'}
          </button>
        </div>
      </div>
    </div>
  )
}
```

### Auto-Refresh Context

Create `dashboard/src/contexts/AutoRefreshContext.tsx`:

```typescript
import { createContext, useContext, useState, useEffect, ReactNode } from 'react'

interface AutoRefreshContextType {
  enabled: boolean
  interval: number  // milliseconds
  setEnabled: (enabled: boolean) => void
  setInterval: (interval: number) => void
}

const AutoRefreshContext = createContext<AutoRefreshContextType | null>(null)

const STORAGE_KEY = 'autoRefresh'
const DEFAULT_INTERVAL = 60000  // 1 minute

export function AutoRefreshProvider({ children }: { children: ReactNode }) {
  const [enabled, setEnabled] = useState(() => {
    const stored = localStorage.getItem(STORAGE_KEY)
    return stored ? JSON.parse(stored).enabled : false
  })
  const [interval, setInterval] = useState(() => {
    const stored = localStorage.getItem(STORAGE_KEY)
    return stored ? JSON.parse(stored).interval : DEFAULT_INTERVAL
  })

  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ enabled, interval }))
  }, [enabled, interval])

  return (
    <AutoRefreshContext.Provider value={{ enabled, interval, setEnabled, setInterval }}>
      {children}
    </AutoRefreshContext.Provider>
  )
}

export function useAutoRefresh() {
  const context = useContext(AutoRefreshContext)
  if (!context) throw new Error('useAutoRefresh must be used within AutoRefreshProvider')
  return context
}
```

### Settings Page Updates

Modify `dashboard/src/pages/Settings.tsx`:

```typescript
import { useAutoRefresh } from '../contexts/AutoRefreshContext'
import { ConfirmDeleteModal } from '../components/ConfirmDeleteModal'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { useState } from 'react'

export function SettingsPage() {
  const { enabled, interval, setEnabled, setInterval } = useAutoRefresh()
  const [showDeleteModal, setShowDeleteModal] = useState(false)
  const queryClient = useQueryClient()

  const clearMutation = useMutation({
    mutationFn: () => fetch('/api/requests', { method: 'DELETE' }),
    onSuccess: () => {
      queryClient.invalidateQueries()
      toast.success('All requests cleared')
    }
  })

  return (
    <div className="space-y-8">
      <section>
        <h2 className="text-lg font-semibold mb-4">Auto-Refresh</h2>
        <div className="space-y-4">
          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={enabled}
              onChange={e => setEnabled(e.target.checked)}
            />
            Enable auto-refresh
          </label>
          {enabled && (
            <select
              value={interval}
              onChange={e => setInterval(Number(e.target.value))}
              className="border rounded px-3 py-2"
            >
              <option value={30000}>30 seconds</option>
              <option value={60000}>1 minute</option>
              <option value={300000}>5 minutes</option>
              <option value={600000}>10 minutes</option>
            </select>
          )}
        </div>
      </section>

      <section>
        <h2 className="text-lg font-semibold mb-4">Data Management</h2>
        <button
          onClick={() => setShowDeleteModal(true)}
          className="px-4 py-2 bg-red-600 text-white rounded"
        >
          Clear All Requests
        </button>
      </section>

      <ConfirmDeleteModal
        isOpen={showDeleteModal}
        onClose={() => setShowDeleteModal(false)}
        onConfirm={clearMutation.mutateAsync}
      />
    </div>
  )
}
```

---

## Deliverable 3: Gemini Configuration

### config.yaml.example Update

Add to providers section:

```yaml
providers:
  anthropic:
    base_url: "https://api.anthropic.com"
    format: "anthropic"
    api_key: "${ANTHROPIC_API_KEY}"

  openai:
    base_url: "https://api.openai.com"
    format: "openai"
    api_key: "${OPENAI_API_KEY}"

  # Gemini uses OpenAI-compatible API
  gemini:
    base_url: "https://generativelanguage.googleapis.com/v1beta/openai/"
    format: "openai"
    api_key: "${GEMINI_API_KEY}"
    # Available models:
    # - gemini-2.0-flash-exp (fastest, experimental)
    # - gemini-1.5-pro (most capable)
    # - gemini-1.5-flash (balanced)

subagents:
  enable: true
  mappings:
    # Route code review to Gemini Flash for speed
    code-reviewer: "gemini:gemini-2.0-flash-exp"
    # Route complex analysis to Gemini Pro
    architect: "gemini:gemini-1.5-pro"
```

### CLAUDE.md Documentation Update

Add section under Configuration:

```markdown
### Gemini Provider

Gemini models can be used via Google's OpenAI-compatible API:

```yaml
providers:
  gemini:
    base_url: "https://generativelanguage.googleapis.com/v1beta/openai/"
    format: "openai"
    api_key: "YOUR_GEMINI_API_KEY"
```

**Available Models:**
- `gemini-2.0-flash-exp` - Fastest, experimental
- `gemini-1.5-pro` - Most capable
- `gemini-1.5-flash` - Balanced speed/capability

**Subagent Routing Example:**
```yaml
subagents:
  mappings:
    code-reviewer: "gemini:gemini-2.0-flash-exp"
```

**API Key:**
Get your API key from [Google AI Studio](https://aistudio.google.com/apikey)
```

---

## Testing Commands

```bash
# Run all tests
just test

# Type check frontend
cd dashboard && npm run typecheck

# Lint
just check

# Manual testing
just docker
# Then access http://localhost:3000/routing
```

---

## Common Patterns

### Error Handling (Backend)
```go
if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
    return
}
```

### Loading States (Frontend)
```typescript
if (isLoading) return <div>Loading...</div>
if (error) return <div>Error: {error.message}</div>
```

### Toast Notifications
```typescript
import { toast } from 'sonner'  // or similar

toast.success('Operation completed')
toast.error('Operation failed')
```
