# Sprint Plan: Message Content Parser

**Generated**: 2025-12-24-170000
**Source**: STATUS-20251224.md (dashboard-parity evaluation)
**Epic**: brandon-fryslie_claude-code-proxy-kqw
**Topic**: message-content-parser

---

## Sprint Goal

Build a MessageContent component that parses and renders Anthropic message content blocks with proper formatting for text, tool calls, tool results, images, and system prompts.

---

## Scope

### In Scope
- Core MessageContent component with recursive rendering
- Text content with formatting (via formatters)
- Tool use block rendering (ToolUse component)
- Tool result block rendering (ToolResult component)
- Image content rendering (ImageContent component)
- System reminder parsing and display
- Tool definition parsing and display (from system prompts)
- Unknown content type handling with raw JSON fallback

### Out of Scope
- TodoList rendering (separate epic)
- Code syntax highlighting (separate sprint: code-viewer-highlighting)
- Copy-to-clipboard functionality (separate sprint: copy-to-clipboard)
- Message flow diagrams (Phase 2: Advanced features)

---

## Work Items

### P0-1: Create MessageContent Component Structure

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: None
**Spec Reference**: CLAUDE.md - Message Rendering | **Status Reference**: STATUS-20251224.md lines 35-39

#### Description
Port the core MessageContent component from old dashboard (`web/app/components/MessageContent.tsx`) to new dashboard (`dashboard/src/components/`). This component handles recursive rendering of different content block types.

#### Acceptance Criteria
- [ ] MessageContent component created at `dashboard/src/components/MessageContent.tsx`
- [ ] Component handles string content (plain text)
- [ ] Component handles array of content items (recursive)
- [ ] Component handles single content object with type switching
- [ ] Content types supported: `text`, `tool_use`, `tool_result`, `image`, unknown
- [ ] Unknown content types show warning UI with expandable raw JSON
- [ ] Component uses TypeScript with proper interfaces for ContentItem
- [ ] Unit tests verify all content type branches execute correctly

#### Technical Notes
- Reference old component at lines 23-132 for structure
- Key pattern: Type check content (string/array/object), then switch on `type` field
- Use React's `dangerouslySetInnerHTML` for formatted text (after sanitization via formatters)
- Ensure deep nesting works (content arrays within content arrays)

---

### P0-2: Implement Text Content Rendering with Formatting

**Status**: Not Started
**Complexity**: Low
**Dependencies**: P0-1
**Spec Reference**: CLAUDE.md - Message Rendering | **Status Reference**: STATUS-20251224.md lines 112-119

#### Description
Handle plain text and text blocks with proper HTML formatting using the formatters utility. Support large text handling with line breaks and whitespace preservation.

#### Acceptance Criteria
- [ ] Plain string content renders in styled div with border/shadow
- [ ] Text blocks (type: "text") render with `text` field extracted
- [ ] Content passed through `formatLargeText()` formatter before rendering
- [ ] Line breaks preserved (`\n` → `<br>` or `whitespace-pre-wrap`)
- [ ] Long text doesn't break layout (word-wrap, overflow handling)
- [ ] Styled with bg-white, rounded-lg, border, padding matching old dashboard
- [ ] Integration test: Render 500+ line text block without performance issues

#### Technical Notes
- Port `formatLargeText()` from `web/app/utils/formatters.ts` to `dashboard/src/lib/formatters.ts`
- Old component uses `dangerouslySetInnerHTML` - ensure XSS safety by sanitizing in formatter
- Consider creating `dashboard/src/lib/formatters.ts` if it doesn't exist

---

### P0-3: Create ToolUse Component

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-1
**Spec Reference**: CLAUDE.md - Tool Use Display | **Status Reference**: STATUS-20251224.md lines 45-48, 118

#### Description
Build the ToolUse component to display tool execution requests with parameters, special handling for Edit/Read/TodoWrite tools, and expandable parameter views.

#### Acceptance Criteria
- [ ] ToolUse component created at `dashboard/src/components/ToolUse.tsx`
- [ ] Displays tool name, ID, and parameters in styled card
- [ ] Shows parameter count badge and expand/collapse for 3+ parameters
- [ ] Copy button copies entire tool call as JSON to clipboard
- [ ] Special rendering for Edit tool: shows code diff (uses CodeDiff component)
- [ ] Special rendering for Read tool: shows file path being read
- [ ] Special rendering for TodoWrite tool: shows todo list (uses TodoList component)
- [ ] Complex parameter values (objects) render as expandable details
- [ ] Large string parameters (200+ chars) show truncated with expand button
- [ ] Gradient background (indigo-50 to blue-50) with tool icon
- [ ] Unit tests for parameter rendering (string/object/array types)
- [ ] Integration test: Render Edit tool with 1000-line old_string/new_string

#### Technical Notes
- Reference `web/app/components/ToolUse.tsx` lines 1-209
- Icons: Wrench (main), Terminal, Zap for visual hierarchy
- Use formatters: `formatValue()`, `formatJSON()`, `isComplexObject()`
- CodeDiff and TodoList components may not exist yet - create placeholders or defer special rendering

---

### P0-4: Create ToolResult Component

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-1
**Spec Reference**: CLAUDE.md - Tool Result Display | **Status Reference**: STATUS-20251224.md lines 45-50, 119

#### Description
Build the ToolResult component to display tool execution results, auto-detect code content, handle errors, and integrate with CodeViewer for syntax highlighting.

#### Acceptance Criteria
- [ ] ToolResult component created at `dashboard/src/components/ToolResult.tsx`
- [ ] Displays tool result content with success (green) or error (red) styling
- [ ] Auto-detects code content using heuristics (line numbers, language keywords)
- [ ] Code content renders in CodeViewer component with syntax highlighting
- [ ] JSON content renders in formatted pre block with mono font
- [ ] Plain text renders with line breaks preserved
- [ ] Large content (500+ chars) truncated with expand button
- [ ] Extracts code from `cat -n` format (removes line number prefixes)
- [ ] Error results show AlertCircle icon and red color scheme
- [ ] Success results show CheckCircle icon and green color scheme
- [ ] Shows tool ID if provided (in mono font badge)
- [ ] Expandable raw data structure for complex objects
- [ ] Unit tests for content type detection (code vs JSON vs text)
- [ ] Integration test: Render 2000-line Read tool result with syntax highlighting

#### Technical Notes
- Reference `web/app/components/ToolResult.tsx` lines 1-257
- Code detection pattern: `/^\s*\d+→/m` for cat -n output
- Heuristics: Check for keywords (function, const, import, class, etc.)
- Requires CodeViewer component (separate sprint) - create placeholder or defer
- Content structure variations: `content.text`, `content.content`, or direct string

---

### P0-5: Create ImageContent Component

**Status**: Not Started
**Complexity**: Low
**Dependencies**: P0-1
**Spec Reference**: CLAUDE.md - Image Display | **Status Reference**: STATUS-20251224.md lines 49, 119

#### Description
Build the ImageContent component to render base64-encoded images with download and fullscreen capabilities.

#### Acceptance Criteria
- [ ] ImageContent component created at `dashboard/src/components/ImageContent.tsx`
- [ ] Parses image data from Claude API format (`source.data`, `source.media_type`)
- [ ] Parses image data from alternative format (`data`, `media_type`)
- [ ] Constructs data URI from base64 data
- [ ] Displays image in bordered container with gray background
- [ ] Download button saves image with media type extension
- [ ] Fullscreen button opens modal overlay with large image
- [ ] Handles image load errors gracefully (shows error UI with raw data)
- [ ] Modal closes on click outside or X button
- [ ] Shows media type label (e.g., "image/png")
- [ ] Unit tests for data URI construction from various formats
- [ ] Integration test: Render 5MB image without blocking UI

#### Technical Notes
- Reference `web/app/components/ImageContent.tsx` lines 1-144
- Data URI format: `data:${mediaType};base64,${imageData}`
- Icons: ImageIcon, Download, Maximize2, X from lucide-react
- Fullscreen modal uses fixed positioning with z-50
- Error state shows expandable raw JSON for debugging

---

### P1-6: Add System Reminder Parsing

**Status**: Not Started
**Complexity**: Medium
**Dependencies**: P0-2
**Spec Reference**: CLAUDE.md - Message Rendering | **Status Reference**: STATUS-20251224.md lines 112-119

#### Description
Parse and extract `<system-reminder>` tags from message content, render them in collapsible sections separate from main content.

#### Acceptance Criteria
- [ ] Detects `<system-reminder>` tags in text content
- [ ] Extracts reminder content and regular text separately
- [ ] Regular text renders normally (no tags visible)
- [ ] Reminders hidden by default with expandable toggle
- [ ] Shows reminder count: "N system reminder(s)"
- [ ] AlertCircle icon used for reminder indicator
- [ ] Reminders render in gray monospace font with border
- [ ] Multiple reminders in one message all extracted and displayed
- [ ] Regex parsing handles multi-line reminder content
- [ ] Unit tests for reminder extraction (0, 1, multiple reminders)
- [ ] Integration test: Message with 5 reminders and 1000 words of text

#### Technical Notes
- Reference `web/app/components/MessageContent.tsx` lines 315-400
- Regex: `/<system-reminder>([\s\S]*?)<\/system-reminder>/g`
- Pattern: Split content into parts array `[{type: 'text'|'reminder', content: string}]`
- Render text parts normally, reminder parts in collapsed section

---

### P1-7: Add Tool Definition Parsing

**Status**: Not Started
**Complexity**: High
**Dependencies**: P0-2
**Spec Reference**: CLAUDE.md - Message Rendering | **Status Reference**: STATUS-20251224.md lines 112-119

#### Description
Parse `<functions>` tags in system prompts, extract individual `<function>` definitions, render them as expandable tool cards with parameter details.

#### Acceptance Criteria
- [ ] Detects `<functions>` tags in text content
- [ ] Extracts individual `<function>` blocks within functions tag
- [ ] Parses JSON tool definitions from function blocks
- [ ] Shows tool count in header: "N tools defined for this conversation"
- [ ] All tools collapsed by default with "Show Tools" toggle
- [ ] Each tool renders as card with name, description, parameter count
- [ ] Parameter count badge shows total parameters
- [ ] Required parameter count badge (orange) if any exist
- [ ] Expand individual tool shows parameter list with types and descriptions
- [ ] Required parameters marked with red "required" badge
- [ ] Optional parameters marked with gray "optional" badge
- [ ] Invalid tool JSON shows error card with raw content
- [ ] Expandable raw definition for debugging
- [ ] Gradient green background for tools section (emerald-50 to green-50)
- [ ] Unit tests for JSON parsing (valid/invalid tool definitions)
- [ ] Integration test: System prompt with 20 tool definitions

#### Technical Notes
- Reference `web/app/components/MessageContent.tsx` lines 134-313
- Regex for functions: `/<functions>([\s\S]*?)<\/functions>/`
- Regex for individual tools: `/<function>([\s\S]*?)<\/function>/g`
- Each function block contains JSON - use `JSON.parse()` with try/catch
- Tool definition structure: `{name, description, parameters: {properties, required}}`
- Icons: Wrench (main), Database for visual hierarchy

---

### P2-8: Create Utility Formatters

**Status**: Not Started
**Complexity**: Low
**Dependencies**: None
**Spec Reference**: CLAUDE.md - Technical Patterns | **Status Reference**: STATUS-20251224.md lines 55-62

#### Description
Port formatting utilities from old dashboard to support text rendering, JSON formatting, and value display.

#### Acceptance Criteria
- [ ] File created: `dashboard/src/lib/formatters.ts`
- [ ] `formatLargeText(text: string): string` - formats text with line breaks
- [ ] `formatJSON(obj: any): string` - JSON.stringify with 2-space indent
- [ ] `formatValue(value: any): string` - converts any value to display string
- [ ] `isComplexObject(value: any): boolean` - detects objects/arrays
- [ ] `truncateText(text: string, maxLength: number): string` - truncates with ellipsis
- [ ] All functions handle null/undefined gracefully
- [ ] Unit tests for each formatter with edge cases
- [ ] TypeScript types exported for all functions

#### Technical Notes
- Reference `web/app/utils/formatters.ts`
- `formatLargeText` should handle HTML escaping to prevent XSS
- Consider using DOMPurify or similar for sanitization
- Edge cases: null, undefined, circular references (JSON), empty strings

---

## Dependencies

```
P0-1 (MessageContent structure)
  ├─> P0-2 (Text rendering)
  │     ├─> P1-6 (System reminders)
  │     └─> P1-7 (Tool definitions)
  ├─> P0-3 (ToolUse component)
  ├─> P0-4 (ToolResult component)
  └─> P0-5 (ImageContent component)

P2-8 (Formatters) ─> P0-2, P0-3, P0-4
```

**Critical Path**: P2-8 → P0-1 → P0-2 → P1-6, P1-7

---

## Recommended Sprint Sequence

### Week 1: Foundation (P2-8, P0-1, P0-2)
1. **Day 1-2**: Create formatters (P2-8) + MessageContent shell (P0-1)
2. **Day 3-4**: Text rendering (P0-2) + basic integration tests
3. **Day 5**: System reminders (P1-6)

### Week 2: Components (P0-3, P0-4, P0-5, P1-7)
1. **Day 1-2**: ToolUse component (P0-3)
2. **Day 3-4**: ToolResult component (P0-4)
3. **Day 5**: ImageContent component (P0-5)

### Week 3: Advanced + Polish (P1-7, testing)
1. **Day 1-3**: Tool definitions (P1-7)
2. **Day 4-5**: Integration testing, bug fixes, edge cases

**Total Complexity**: HIGH (399 LOC reference component + 8 sub-components)

---

## Risk Assessment

### High Risks
1. **CodeViewer Integration**: P0-4 depends on CodeViewer from separate sprint
   - **Mitigation**: Create placeholder CodeViewer or implement basic version inline
   - **Impact**: ToolResult rendering incomplete without syntax highlighting

2. **Formatter XSS Vulnerability**: `formatLargeText` uses `dangerouslySetInnerHTML`
   - **Mitigation**: Use DOMPurify or proper HTML escaping in formatters
   - **Impact**: Security vulnerability if user-controlled content rendered unsafely

3. **Large Content Performance**: Rendering 1000+ line tool results could freeze UI
   - **Mitigation**: Implement virtualization or lazy rendering for large content
   - **Impact**: Poor UX with slow API responses

### Medium Risks
1. **Tool Definition Parsing**: Complex regex and JSON parsing could fail on edge cases
   - **Mitigation**: Extensive unit tests with malformed tool definitions
   - **Impact**: System prompts render incorrectly or cause errors

2. **Content Type Detection**: Heuristics for code vs JSON vs text may misclassify
   - **Mitigation**: Test with real API responses from production logs
   - **Impact**: Wrong rendering (code as text, or vice versa)

### Low Risks
1. **Image Rendering**: Base64 data URI support varies by browser
   - **Mitigation**: Test in Chrome, Firefox, Safari
   - **Impact**: Images fail to display in some browsers

---

## Testing Strategy

### Unit Tests
- MessageContent: Content type switching (string/array/object/unknown)
- Formatters: Edge cases (null, undefined, circular refs, XSS attempts)
- ToolUse: Parameter rendering (primitives, objects, arrays)
- ToolResult: Content detection (code/JSON/text), extraction (cat -n format)
- ImageContent: Data URI construction from various formats
- SystemReminders: Regex extraction (0, 1, multiple reminders)
- ToolDefinitions: JSON parsing (valid/invalid), parameter metadata

### Integration Tests
- Render complete API response with mixed content types
- Large content handling (2000-line code block, 100 tool definitions)
- Error scenarios (malformed JSON, missing fields, invalid images)
- Recursive content (arrays within arrays, 5+ levels deep)

### E2E Tests (Optional)
- Load real request from API, verify all content blocks render
- Click expand/collapse buttons, verify state transitions
- Copy tool use JSON, verify clipboard contents

---

## Blockers and Questions

### Questions for Product Owner
1. **Migration Timeline**: Should we maintain old dashboard components during transition?
   - **Impact**: Determines if we need shared component library or full port

2. **Syntax Highlighting Library**: Which library for CodeViewer (Prism.js? Shiki? highlight.js)?
   - **Impact**: Bundle size, language support, performance trade-offs

3. **XSS Protection**: Is DOMPurify acceptable dependency, or use custom sanitization?
   - **Impact**: Security vs bundle size

### Technical Decisions Needed
1. **CodeViewer Dependency**: Implement basic version in this sprint, or wait for code-viewer-highlighting sprint?
   - **Recommendation**: Create basic placeholder (pre + mono font) to unblock P0-4

2. **TodoList Component**: P0-3 references TodoList for TodoWrite tool rendering
   - **Recommendation**: Skip TodoWrite special rendering for now, show raw parameters

3. **Component Location**: Should components go in `dashboard/src/components/` or `dashboard/src/components/message/`?
   - **Recommendation**: Flat structure initially, refactor to subdirectories if too many files

---

## Definition of Done

See: `DOD-20251224-170000.md`

---

## Success Metrics

### Functional Completeness
- [ ] All 5 content types render correctly (text, tool_use, tool_result, image, unknown)
- [ ] System reminders parse and display from real API responses
- [ ] Tool definitions render from real system prompts (20+ tools)
- [ ] Copy-to-clipboard works for tool use blocks

### Performance
- [ ] 2000-line tool result renders in < 500ms
- [ ] 100 tool definitions expand/collapse without lag
- [ ] No memory leaks after rendering 100+ messages

### Quality
- [ ] 80%+ unit test coverage for all components
- [ ] 0 TypeScript errors
- [ ] 0 ESLint warnings
- [ ] Passes accessibility audit (WCAG 2.1 AA)

### User Experience
- [ ] Expand/collapse states persist during navigation (optional)
- [ ] Visual hierarchy clear (tool use vs tool result vs errors)
- [ ] Mobile responsive (works on 375px width)
