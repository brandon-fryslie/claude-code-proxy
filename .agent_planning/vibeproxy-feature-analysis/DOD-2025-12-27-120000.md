# Definition of Done: Gemini + Multi-Account Features

**Generated:** 2025-12-27-120000
**Plan:** PLAN-2025-12-27-120000.md

---

## Sprint Scope

This sprint delivers:
1. **Gemini Provider Support** - Configuration and documentation for routing to Google Gemini models
2. **Multi-Account Round-Robin** - Support multiple API keys per provider with automatic failover

Deferred:
- OAuth authentication (separate roadmap topic)
- Comprehensive test suite (larger effort)
- Health check endpoints (future enhancement)
- Max tokens configuration (future enhancement)

---

## Acceptance Criteria

### P0: Gemini Provider Support

**Configuration & Documentation:**
- [ ] Add Gemini example to `config.yaml.example` with correct base URL (`https://generativelanguage.googleapis.com/v1beta/openai/`)
- [ ] Document API key format (Gemini uses `api_key` query parameter, not Authorization header)
- [ ] Add subagent mapping example for Gemini models (e.g., `code-reviewer: "gemini:gemini-2.0-flash-exp"`)
- [ ] Document available Gemini models in comments (gemini-1.5-pro, gemini-1.5-flash, gemini-2.0-flash-exp)

**Validation:**
- [ ] Test request forwarding to Gemini API with sample agent
- [ ] Verify streaming responses work correctly
- [ ] Verify token usage is captured and displayed in dashboard
- [ ] Confirm error handling works (invalid API key, rate limits)

**User Experience:**
- [ ] Clear setup instructions in README or docs
- [ ] Troubleshooting guide for common Gemini API issues
- [ ] Example of successful Gemini routing in proxy logs

---

### P1: Multi-Account Round-Robin with Failover

**Configuration Schema:**
- [ ] Support `api_keys: ["key1", "key2", "key3"]` array in provider config
- [ ] Maintain backward compatibility with single `api_key: "xxx"` format
- [ ] Validate at startup that at least one API key is provided
- [ ] Document multi-account config in `config.yaml.example`

**Round-Robin Logic:**
- [ ] Implement round-robin selection (start with account 0, increment on each request)
- [ ] Thread-safe account selection (use mutex or atomic counter)
- [ ] Evenly distribute load across healthy accounts

**Failover Behavior:**
- [ ] On HTTP 429 (rate limit), immediately try next account (up to N total attempts)
- [ ] On HTTP 401 (invalid key), mark account as unhealthy and skip it
- [ ] On HTTP 5xx errors, retry with next account (configurable retry count)
- [ ] On network errors, retry with next account
- [ ] Track which accounts are healthy vs. unhealthy

**State Management:**
- [ ] Per-account error counters (reset after cooldown period)
- [ ] Circuit breaker pattern: temporarily disable account after N consecutive failures
- [ ] Cooldown period: re-enable unhealthy accounts after X minutes (default: 5 min)
- [ ] Health check logging: report account health status on startup and periodically

**Logging & Observability:**
- [ ] Log which account index was used for each request (e.g., "Using account 2/3")
- [ ] Log failover events (e.g., "Account 0 rate limited, trying account 1")
- [ ] Log when accounts are marked unhealthy or re-enabled
- [ ] Dashboard shows requests grouped by account (if feasible)

**Error Handling:**
- [ ] If all accounts are unhealthy, return 503 Service Unavailable with clear error
- [ ] Preserve original error message from provider in response
- [ ] Don't retry on client errors (4xx except 429)

---

## Unit Test Coverage (Recommended)

While comprehensive test infrastructure is deferred, these critical paths should have unit tests:

**AccountManager (Multi-Account Feature):**
- [ ] Test round-robin selection cycles through all accounts
- [ ] Test marking account unhealthy removes it from rotation
- [ ] Test cooldown re-enables account after duration
- [ ] Test thread safety with concurrent account requests
- [ ] Test edge case: all accounts unhealthy returns error

**Config Validation:**
- [ ] Test loading config with `api_keys` array
- [ ] Test loading config with single `api_key` (backward compatibility)
- [ ] Test validation fails when no API key provided
- [ ] Test empty strings in `api_keys` array are filtered out

---

## Integration Testing Checklist

**Gemini Provider:**
- [ ] Manual test: Route request to Gemini API with valid key
- [ ] Manual test: Streaming response from Gemini
- [ ] Manual test: Invalid API key returns proper error
- [ ] Manual test: Token usage appears in dashboard

**Multi-Account Round-Robin:**
- [ ] Integration test: Mock server returns 429, verify failover to next account
- [ ] Integration test: Mock server returns 401, verify account marked unhealthy
- [ ] Integration test: Mock server returns 500, verify retry with next account
- [ ] Integration test: All accounts fail, verify 503 response
- [ ] Integration test: Account cooldown re-enables after duration
- [ ] Load test: Verify even distribution across 3 accounts (±5% variance)

---

## Documentation Requirements

**README or Docs:**
- [ ] Gemini setup guide with example configuration
- [ ] Multi-account setup guide with example configuration
- [ ] Troubleshooting section for common issues
- [ ] Migration guide for users with single API key

**Code Comments:**
- [ ] Document `AccountManager` interface and methods
- [ ] Comment on thread safety guarantees
- [ ] Explain cooldown and circuit breaker logic

**Config File:**
- [ ] Comments in `config.yaml.example` explaining all new fields
- [ ] Example configurations for common scenarios (2 accounts, 5 accounts, etc.)

---

## Performance & Quality Gates

**No Regressions:**
- [ ] Existing single-account requests have same latency (±5ms)
- [ ] No memory leaks in long-running tests
- [ ] No goroutine leaks (verify with `runtime.NumGoroutine()`)

**Code Quality:**
- [ ] No linter warnings in new code
- [ ] All exported functions have doc comments
- [ ] Error messages are clear and actionable

**Observability:**
- [ ] All error paths log with sufficient context
- [ ] Success paths log at appropriate level (info/debug)
- [ ] Log format is consistent across new code

---

## Definition of "Done"

This sprint is complete when:

1. ✅ All acceptance criteria above are checked
2. ✅ Gemini provider works end-to-end with real API
3. ✅ Multi-account failover works end-to-end with mock API
4. ✅ Documentation is clear and complete
5. ✅ No high-severity bugs identified
6. ✅ Code is merged to main branch
7. ✅ Feature is deployable to production

---

## Open Questions (To Be Resolved During Implementation)

1. Should `account_index` be added to `RequestLog` database table?
   - **Recommendation:** Yes, for debugging and analytics

2. Should health check endpoint be added this sprint?
   - **Recommendation:** No, defer to future sprint

3. Should rate limit headers be parsed and used proactively?
   - **Recommendation:** No, defer to future sprint

4. Should Gemini API key be sent as query param or Bearer token?
   - **To Test:** Verify during Gemini integration testing
