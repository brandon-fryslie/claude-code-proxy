# Implementation Context: Unified Conversation Search

**For:** Write-only implementation agent
**Sprint:** 2026-01-12

---

## Backend Implementation

### File: proxy/internal/model/models.go

**Add after SearchOptions struct (around line 339):**

```go
// MessageSearchResult represents a single message match
type MessageSearchResult struct {
    UUID       string `json:"uuid"`
    Type       string `json:"type"`
    IsSubagent bool   `json:"isSubagent"`
    Snippet    string `json:"snippet"`
    Timestamp  string `json:"timestamp"`
}

// ConversationSearchResult groups message matches by conversation
type ConversationSearchResult struct {
    ConversationID string                `json:"conversationId"`
    ProjectName    string                `json:"projectName"`
    ProjectPath    string                `json:"projectPath"`
    LastActivity   time.Time             `json:"lastActivity"`
    Messages       []MessageSearchResult `json:"messages"`
}
```

**Modify SearchOptions (add field):**
```go
MessageTypes []string // "user", "claude", "subagent", "other"
```

**Modify SearchResults:**
```go
Results []*ConversationSearchResult `json:"results"` // Changed from ConversationMatch
```

---

### File: proxy/internal/service/storage_sqlite.go

**Replace SearchConversations method (lines 1324-1427):**

Key SQL query:
```sql
SELECT
    c.id, c.project_name, c.project_path, c.end_time,
    f.message_uuid,
    m.type, m.agent_id,
    snippet(conversations_fts, 3, '', '', '...', 20) AS snippet,
    m.timestamp
FROM conversations_fts f
JOIN conversations c ON f.conversation_id = c.id
JOIN conversation_messages m ON f.message_uuid = m.uuid
WHERE conversations_fts MATCH ?
  AND (
    (? AND m.type = 'user')
    OR (? AND m.type = 'assistant' AND m.agent_id IS NULL)
    OR (? AND m.type = 'assistant' AND m.agent_id IS NOT NULL)
    OR (? AND m.type NOT IN ('user', 'assistant'))
  )
ORDER BY c.end_time DESC, m.timestamp ASC
```

**Filter logic:**
- Parse `MessageTypes` from options
- Default all true if empty
- Map: user→arg1, claude→arg2, subagent→arg3, other→arg4
- Group results by conversation_id in Go code

---

### File: proxy/internal/handler/data_handler.go

**Modify SearchConversations handler (lines 536-577):**

```go
// Parse types filter
typesParam := r.URL.Query().Get("types")
var messageTypes []string
if typesParam != "" {
    messageTypes = strings.Split(typesParam, ",")
}

opts := model.SearchOptions{
    Query:        query,
    ProjectPath:  projectPath,
    MessageTypes: messageTypes,
    Limit:        limit,
    Offset:       offset,
}
```

---

## Frontend Implementation

### File: dashboard/src/lib/types.ts

**Add after ConversationDetail (line 307):**

```typescript
export interface SearchFilters {
  user: boolean
  claude: boolean
  subagent: boolean
  other: boolean
}

export interface MessageSearchResult {
  uuid: string
  type: string
  isSubagent: boolean
  snippet: string
  timestamp: string
}

export interface ConversationSearchResult {
  conversationId: string
  projectName: string
  projectPath: string
  lastActivity: string
  messages: MessageSearchResult[]
}

export interface SearchResultsResponse {
  query: string
  results: ConversationSearchResult[]
  total: number
  limit: number
  offset: number
}
```

---

### File: dashboard/src/lib/api.ts

**Add after useConversationMessages (line 216):**

```typescript
interface ConversationSearchParams {
  query: string
  types?: string[]
  limit?: number
  offset?: number
}

export function useConversationSearch(params: ConversationSearchParams | null) {
  const queryString = params ? buildQueryString({
    q: params.query,
    types: params.types?.join(','),
    limit: params.limit || 50,
    offset: params.offset || 0,
  }) : ''

  return useQuery({
    queryKey: ['conversations', 'search', params],
    queryFn: () => fetchAPI<SearchResultsResponse>(`/conversations/search${queryString}`),
    enabled: !!params && params.query.length > 0,
  })
}
```

---

### New File: dashboard/src/components/features/GlobalSearchResults.tsx

```typescript
import { type FC } from 'react'
import { User, Bot, Cpu, FileText } from 'lucide-react'
import type { ConversationSearchResult } from '@/lib/types'

interface GlobalSearchResultsProps {
  results: ConversationSearchResult[]
  query: string
  isLoading: boolean
  onSelectConversation: (id: string) => void
}

export const GlobalSearchResults: FC<GlobalSearchResultsProps> = ({
  results,
  query,
  isLoading,
  onSelectConversation,
}) => {
  if (isLoading) {
    return <div className="p-4 text-center text-[var(--color-text-muted)]">Searching...</div>
  }

  if (results.length === 0) {
    return <div className="p-4 text-center text-[var(--color-text-muted)]">No results found</div>
  }

  return (
    <div className="flex-1 overflow-y-auto">
      {results.map((conv) => (
        <div key={conv.conversationId} className="border-b border-[var(--color-border)]">
          {/* Conversation header */}
          <div className="px-3 py-2 bg-[var(--color-bg-secondary)] sticky top-0">
            <span className="text-sm font-medium">{conv.projectName}</span>
          </div>
          {/* Message results */}
          {conv.messages.map((msg) => (
            <button
              key={msg.uuid}
              onClick={() => onSelectConversation(conv.conversationId)}
              className="w-full px-3 py-2 text-left hover:bg-[var(--color-bg-hover)]"
            >
              <div className="flex items-center gap-2 mb-1">
                <TypeBadge type={msg.type} isSubagent={msg.isSubagent} />
                <span className="text-xs text-[var(--color-text-muted)]">
                  {new Date(msg.timestamp).toLocaleTimeString()}
                </span>
              </div>
              <div className="text-sm text-[var(--color-text-secondary)] line-clamp-2">
                {msg.snippet}
              </div>
            </button>
          ))}
        </div>
      ))}
    </div>
  )
}

function TypeBadge({ type, isSubagent }: { type: string; isSubagent: boolean }) {
  if (type === 'user') {
    return <span className="px-1.5 py-0.5 text-xs bg-blue-100 text-blue-700 rounded">User</span>
  }
  if (isSubagent) {
    return <span className="px-1.5 py-0.5 text-xs bg-purple-100 text-purple-700 rounded">Subagent</span>
  }
  if (type === 'assistant') {
    return <span className="px-1.5 py-0.5 text-xs bg-green-100 text-green-700 rounded">Claude</span>
  }
  return <span className="px-1.5 py-0.5 text-xs bg-gray-100 text-gray-700 rounded">Other</span>
}
```

---

### File: dashboard/src/components/features/ConversationSearch.tsx

**Add filter checkboxes (after search input, before closing div):**

```tsx
{/* Filter checkboxes */}
{showFilters && (
  <div className="flex items-center gap-3 mt-2 text-xs">
    <span className="text-[var(--color-text-muted)]">Show:</span>
    {(['user', 'claude', 'subagent', 'other'] as const).map((type) => (
      <label key={type} className="flex items-center gap-1 cursor-pointer">
        <input
          type="checkbox"
          checked={filters[type]}
          onChange={(e) => onFiltersChange({ ...filters, [type]: e.target.checked })}
          className="w-3 h-3"
        />
        <span className="capitalize">{type === 'subagent' ? 'Subagents' : type}</span>
      </label>
    ))}
  </div>
)}
```

**Add props:**
```typescript
interface ConversationSearchProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
  autoFocus?: boolean
  // New props:
  showFilters?: boolean
  filters?: SearchFilters
  onFiltersChange?: (filters: SearchFilters) => void
}
```

---

### File: dashboard/src/pages/Conversations.tsx

**Add state (around line 163):**
```typescript
const [searchFilters, setSearchFilters] = useState<SearchFilters>({
  user: true, claude: true, subagent: true, other: true,
})
const [debouncedQuery, setDebouncedQuery] = useState('')

// Debounce effect
useEffect(() => {
  const timer = setTimeout(() => setDebouncedQuery(searchQuery), 300)
  return () => clearTimeout(timer)
}, [searchQuery])

// Search hook
const { data: searchResults, isLoading: isSearching } = useConversationSearch(
  debouncedQuery ? {
    query: debouncedQuery,
    types: Object.entries(searchFilters).filter(([_, v]) => v).map(([k]) => k),
  } : null
)
```

**Update ConversationSearch (around line 229):**
```tsx
<ConversationSearch
  value={searchQuery}
  onChange={setSearchQuery}
  showFilters={true}
  filters={searchFilters}
  onFiltersChange={setSearchFilters}
/>
```

**Conditional render (around line 250):**
```tsx
{debouncedQuery && searchResults ? (
  <GlobalSearchResults
    results={searchResults.results}
    query={debouncedQuery}
    isLoading={isSearching}
    onSelectConversation={handleConversationSelect}
  />
) : (
  <ConversationList ... />
)}
```

---

## Database Schema Reference

### conversations_fts (FTS5)
- Column 3 = `content_text` (use in snippet function)
- Tokenizer: porter unicode61

### conversation_messages
- `type`: "user", "assistant", "file-history-snapshot", etc.
- `agent_id`: NULL for main Claude, non-NULL for subagents

---

## Files Summary

| Action | File |
|--------|------|
| Modify | proxy/internal/model/models.go |
| Modify | proxy/internal/service/storage_sqlite.go |
| Modify | proxy/internal/handler/data_handler.go |
| Modify | dashboard/src/lib/types.ts |
| Modify | dashboard/src/lib/api.ts |
| Create | dashboard/src/components/features/GlobalSearchResults.tsx |
| Modify | dashboard/src/components/features/ConversationSearch.tsx |
| Modify | dashboard/src/pages/Conversations.tsx |
