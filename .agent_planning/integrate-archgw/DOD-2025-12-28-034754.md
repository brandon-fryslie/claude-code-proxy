# Definition of Done: ArchGW/Plano Integration - Sprint 1

**Generated:** 2025-12-28-034754
**Plan:** PLAN-2025-12-28-034754.md
**Topic:** integrate-archgw

---

## Sprint Scope

This sprint delivers:
1. ArchGW/Plano running locally with test routing validated
2. ArchGW integrated as a provider in the Go proxy
3. End-to-end request flow working (Claude Code → Go Proxy → ArchGW → Gemini)

Deferred to future sprints:
- Dashboard UI for ArchGW configuration
- Preference-based routing (Arch-Router)
- Multi-provider failover
- Guardrails integration
- OpenTelemetry integration

---

## Acceptance Criteria

### [P0] ArchGW Research & Local Setup

**Deliverable:** ArchGW/Plano running locally and understood

- [ ] ArchGW/Plano running locally via Docker Compose
- [ ] plano_config.yaml configured with at least 2 providers (e.g., Gemini, Qwen)
- [ ] Test request successfully routed through ArchGW to Gemini using curl
- [ ] Streaming responses verified working
- [ ] Latency overhead measured and documented (baseline comparison)
- [ ] Configuration patterns documented (provider setup, API keys, routing rules)

**Verification:**
```bash
# ArchGW responds to health check
curl http://localhost:8080/health

# Successfully routes to Gemini
curl http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"model": "gemini-2.0-flash-exp", "messages": [{"role": "user", "content": "test"}]}'

# Streaming works
curl http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"model": "gemini-2.0-flash-exp", "messages": [{"role": "user", "content": "test"}], "stream": true}'
```

---

### [P0] Design ArchGW Provider Integration

**Deliverable:** Integration design document

- [ ] Design document created in `.agent_planning/integrate-archgw/DESIGN-archgw-provider.md`
- [ ] Provider implementation approach decided (custom vs. reuse OpenAIProvider)
- [ ] Configuration schema defined for ArchGW provider in config.yaml
- [ ] Routing decision logic specified (when to route to ArchGW vs. direct provider)
- [ ] Error handling strategy documented (ArchGW down, model unavailable, etc.)
- [ ] Integration points identified in existing codebase (files to modify, new files to create)

**Verification:**
- Design document addresses:
  - Provider interface implementation approach
  - Configuration structure
  - Request/response format conversion strategy
  - Error handling scenarios
  - Impact on existing routing logic
  - Testing strategy

---

### [P1] Implement ArchGW Provider

**Deliverable:** ArchGW provider integrated into Go proxy

- [ ] ArchGWProvider implemented following Provider interface
- [ ] config.yaml.example updated with archgw provider example
- [ ] Provider initialization in main.go includes ArchGW
- [ ] Subagent mapping supports archgw provider (e.g., `code-reviewer: "archgw:gemini-2.0-flash-exp"`)
- [ ] Request format conversion working (Anthropic → OpenAI for ArchGW)
- [ ] Response format conversion working (OpenAI → Anthropic, streaming and non-streaming)
- [ ] Error handling implemented (ArchGW unavailable returns clear error)
- [ ] Unit tests added for ArchGW provider
- [ ] Integration test passes: curl to Go proxy → routes through ArchGW → returns valid response
- [ ] Existing tests still pass (Anthropic passthrough unchanged)
- [ ] SQLite logging captures ArchGW requests correctly

**Verification:**
```bash
# Build succeeds
cd proxy && go build ./...

# Unit tests pass
cd proxy && go test ./internal/provider/... -v

# Integration test passes
# 1. Start ArchGW: docker-compose up archgw
# 2. Start Go proxy: make run-proxy
# 3. Send test request through proxy:
curl http://localhost:3001/v1/messages \
  -H "Content-Type: application/json" \
  -H "x-api-key: test" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-3-5-sonnet-20241022",
    "messages": [{"role": "user", "content": "test"}],
    "max_tokens": 100,
    "system": ["You are Claude Code", "You are code-reviewer agent"]
  }'
# Expected: Routes to ArchGW, response in Anthropic format

# Existing Anthropic passthrough still works
curl http://localhost:3001/v1/messages \
  -H "Content-Type: application/json" \
  -H "x-api-key: $ANTHROPIC_API_KEY" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-3-5-sonnet-20241022",
    "messages": [{"role": "user", "content": "test"}],
    "max_tokens": 100
  }'
# Expected: Routes directly to Anthropic (no format conversion)

# SQLite logging works
sqlite3 requests.db "SELECT COUNT(*) FROM requests WHERE provider='archgw';"
# Expected: Non-zero count
```

**Code quality checks:**
- [ ] No compilation errors
- [ ] No linter warnings: `cd proxy && golangci-lint run` (if configured)
- [ ] Code follows existing provider pattern (matches anthropic.go structure)
- [ ] Error messages are clear and actionable

---

### [P2] Create Docker Compose Setup

**Deliverable:** Docker Compose configuration for full stack

- [ ] docker-compose.yaml created at repository root
- [ ] ArchGW service defined with correct image and config mount
- [ ] Proxy service updated to reference ArchGW via Docker network
- [ ] Web service integrated into compose setup
- [ ] Environment variables documented in .env.example
- [ ] Volumes configured for persistent data (SQLite DB)
- [ ] Health checks added for all services
- [ ] README.md updated with Docker Compose usage instructions
- [ ] `make docker-up` and `make docker-down` commands added to Makefile
- [ ] Verified: `docker-compose up` starts all services successfully
- [ ] Verified: End-to-end request works through Docker setup

**Verification:**
```bash
# Start all services
make docker-up

# Check all services healthy
docker-compose ps
# Expected: All services "Up" and healthy

# Test request through Docker stack
curl http://localhost:3001/v1/messages \
  -H "Content-Type: application/json" \
  -H "x-api-key: test" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-3-5-sonnet-20241022",
    "messages": [{"role": "user", "content": "test"}],
    "max_tokens": 100,
    "system": ["You are Claude Code", "You are code-reviewer agent"]
  }'
# Expected: 200 response, routed through ArchGW

# Web dashboard accessible
curl http://localhost:5173
# Expected: React app loads

# Clean shutdown
make docker-down
# Expected: All services stop cleanly
```

---

## Overall Sprint Success Criteria

The sprint is complete when ALL of the following are true:

### Functional Requirements
- [ ] ArchGW running locally (via Docker Compose)
- [ ] Go proxy routes subagent requests to ArchGW
- [ ] Responses converted correctly to Anthropic format
- [ ] Direct Anthropic requests still passthrough (no format conversion)
- [ ] Streaming responses work through ArchGW

### Quality Requirements
- [ ] All existing tests pass (no regressions)
- [ ] New unit tests added for ArchGW provider
- [ ] Integration test demonstrates end-to-end flow
- [ ] Error handling tested (ArchGW unavailable scenario)
- [ ] Code review completed (if multi-person team)

### Documentation Requirements
- [ ] Design document written
- [ ] config.yaml.example updated
- [ ] README.md updated with Docker Compose instructions
- [ ] Latency measurements documented

### Deployment Requirements
- [ ] docker-compose.yaml functional
- [ ] Health checks working for all services
- [ ] Makefile targets added for Docker operations

---

## Out of Scope (Not Acceptance Criteria)

These are explicitly NOT required for this sprint:

- Dashboard UI changes
- Preference-based routing logic
- Multi-provider failover
- Performance optimization beyond basic latency measurement
- Production deployment configuration
- Monitoring/alerting setup
- Load testing

---

## Rollback Criteria

If any of these occur, STOP and reassess:

- [ ] Latency overhead exceeds 200ms per request
- [ ] ArchGW format incompatibility blocks integration
- [ ] Existing Anthropic passthrough breaks
- [ ] More than 3 days spent on format conversion debugging
- [ ] Docker setup requires unreasonable complexity (>100 lines config)

In these cases, pause and re-evaluate the integration approach with the user.

---

## Handoff to Next Sprint

When this sprint is complete, prepare for Sprint 2 by:

1. **Document findings:**
   - Actual latency overhead measured
   - ArchGW stability observations
   - Any format conversion edge cases discovered

2. **Create backlog items:**
   - Dashboard UI for ArchGW configuration
   - Preference routing implementation
   - Additional provider support (beyond Gemini)

3. **Update roadmap:**
   - Mark integrate-archgw as "In Progress"
   - Create topics for dashboard-archgw, preference-routing

4. **Notify user:**
   - Demo end-to-end flow
   - Share latency metrics
   - Get feedback on which features to prioritize next
