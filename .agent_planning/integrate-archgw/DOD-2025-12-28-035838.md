# Definition of Done: ArchGW/Plano Integration

**Generated:** 2025-12-28-035838
**Plan:** PLAN-2025-12-28-035838.md
**Topic:** integrate-archgw

---

## Phase 1: Foundation (Research & Basic Wiring)

### P0: ArchGW Research & Local Setup

- [ ] ArchGW/Plano running locally via Docker Compose
- [ ] plano_config.yaml configured with at least 3 providers (Gemini, Qwen, DeepSeek)
- [ ] Test request successfully routed through ArchGW to Gemini using curl
- [ ] Test request successfully routed to Qwen and DeepSeek
- [ ] Streaming responses verified working for all 3 providers
- [ ] Non-streaming responses verified working
- [ ] Latency overhead measured and documented (target: <100ms for ArchGW hop)
- [ ] Error handling tested (invalid model returns clear error)
- [ ] Provider unavailability tested (ArchGW handles gracefully)
- [ ] Configuration patterns documented (provider setup, API keys, routing rules)
- [ ] Research document created: `.agent_planning/integrate-archgw/RESEARCH-archgw.md`

### P0: Design ArchGW Provider Integration

- [ ] Design document created: `.agent_planning/integrate-archgw/DESIGN-archgw-provider.md`
- [ ] Provider implementation approach decided and documented
- [ ] Configuration schema defined for ArchGW provider in config.yaml
- [ ] Routing decision logic specified (when to route to ArchGW vs. direct providers)
- [ ] Error handling strategy documented (ArchGW down, model unavailable, timeout, etc.)
- [ ] Fallback behavior specified (fail vs. retry logic)
- [ ] Format conversion approach documented (reuse OpenAIProvider conversion)
- [ ] Integration points identified (files to modify, new files to create)
- [ ] Logging strategy defined (what to log at each stage)
- [ ] Future extensibility considered (Phase 3 preference routing, Phase 4 guardrails)

### P1: Implement ArchGW Provider

- [ ] ArchGWProvider implemented following Provider interface
- [ ] config.yaml.example updated with archgw provider example showing multiple models
- [ ] Provider initialization in main.go includes ArchGW provider
- [ ] Subagent mapping supports archgw provider (e.g., `code-reviewer: "archgw:gemini-2.0-flash-exp"`)
- [ ] Request format conversion working (Anthropic → OpenAI for ArchGW)
- [ ] Response format conversion working (OpenAI → Anthropic, streaming and non-streaming)
- [ ] Streaming SSE events correctly transformed through conversion pipeline
- [ ] Error handling implemented (ArchGW unavailable returns clear error)
- [ ] Error responses from ArchGW converted to Anthropic format
- [ ] Unit tests added for ArchGW provider (minimum 5 test cases)
- [ ] Integration test passes: curl to Go proxy → routes through ArchGW → returns valid response
- [ ] Existing tests still pass (Anthropic passthrough unchanged, OpenAI routing unchanged)
- [ ] SQLite logging captures ArchGW requests correctly (original request + ArchGW-routed request)
- [ ] Dashboard displays ArchGW requests with correct provider name
- [ ] Logging includes ArchGW routing decision (which model was selected)

### P2: Create Docker Compose Setup

- [ ] docker-compose.yaml created at repository root
- [ ] ArchGW service defined with correct image and configuration mount
- [ ] Proxy service defined with Dockerfile in proxy/
- [ ] Web service defined with Dockerfile in web/
- [ ] Proxy service configured to reference ArchGW via Docker network (http://archgw:8080)
- [ ] Environment variables documented in .env.example (API keys for providers)
- [ ] Volumes configured for persistent data (SQLite DB shared between proxy and web)
- [ ] Health checks added for all services
- [ ] Service dependencies configured (proxy depends_on archgw, web depends_on proxy)
- [ ] README.md updated with Docker Compose usage instructions
- [ ] Makefile updated with docker-up, docker-down, docker-logs commands
- [ ] Verified: `docker-compose up` starts all services successfully
- [ ] Verified: End-to-end request works through Docker setup (client → proxy → archgw → LLM)
- [ ] Verified: Dashboard accessible and displays requests correctly

---

## Phase 2: Core Integration (Production-Ready)

### P1: Comprehensive Error Handling & Fallback

- [ ] Error handling implemented for all ArchGW failure modes
- [ ] Clear error messages returned to client (include provider name, error type)
- [ ] Fallback configuration added to config.yaml (optional per provider)
- [ ] Circuit breaker pattern implemented (configurable thresholds)
- [ ] Circuit breaker state tracked and logged (open/closed/half-open)
- [ ] Fallback attempts logged separately in SQLite (original provider + fallback provider)
- [ ] Dashboard displays fallback events and circuit breaker state
- [ ] Unit tests for all error scenarios (minimum 8 test cases)
- [ ] Integration tests verify fallback behavior
- [ ] Metrics tracked: error rate per provider, fallback rate, circuit breaker trips
- [ ] Documentation updated with error handling configuration options

### P1: Enhanced Monitoring & Observability

- [ ] SQLite schema extended to capture ArchGW-specific fields (provider, model, routing_mode)
- [ ] Request logging includes ArchGW routing decision (which provider/model selected)
- [ ] Latency tracking captures Go proxy overhead separately from ArchGW overhead
- [ ] New API endpoint: GET /api/stats/archgw (ArchGW-specific statistics)
- [ ] Dashboard component created: ArchGWStats.tsx (provider breakdown, latency, errors)
- [ ] Provider breakdown chart shows requests per ArchGW upstream provider
- [ ] Latency chart compares Anthropic vs OpenAI vs ArchGW providers
- [ ] Error rate chart shows success/failure per provider
- [ ] Circuit breaker status displayed in dashboard (open/closed/half-open)
- [ ] Fallback events logged and displayed in request details
- [ ] Dashboard automatically refreshes ArchGW stats every 30 seconds
- [ ] Documentation updated with new metrics and dashboard features

---

## Phase 3: Advanced Routing (Preference & Optimization)

### P1: Preference-Based Routing Configuration

- [ ] Config schema extended with preference routing options
- [ ] Global preference setting supported (optimize_for: cost/speed/quality/balanced)
- [ ] Per-subagent preference override supported
- [ ] Preferences passed to ArchGW correctly (via headers or model alias)
- [ ] ArchGW routing decision captured in response metadata
- [ ] Routing decision logged to SQLite (selected_provider, routing_reason)
- [ ] Dashboard displays routing decisions and preference effectiveness
- [ ] Documentation created: `.agent_planning/integrate-archgw/PREFERENCES.md`
- [ ] Unit tests for preference configuration parsing
- [ ] Integration tests verify correct provider selection based on preferences
- [ ] A/B testing support: Compare cost savings vs. quality impact

### P2: Intelligent Failover & Load Balancing

- [ ] Failover logic implemented for ArchGW provider failures
- [ ] Retry attempts configurable (max_retries, backoff strategy)
- [ ] Preference-preserving retry logic implemented
- [ ] Degraded mode retry implemented (relax preferences on retry)
- [ ] Multiple ArchGW instances supported in configuration
- [ ] Load balancing strategy configurable (round-robin, least-connections)
- [ ] Health checks for ArchGW instances (mark unhealthy instances)
- [ ] Retry attempts logged separately (initial + retries)
- [ ] Dashboard displays retry statistics and success rates
- [ ] Unit tests for failover logic (minimum 6 scenarios)
- [ ] Integration tests verify end-to-end failover behavior
- [ ] Performance tests validate load balancing distribution

---

## Phase 4: Dashboard & Guardrails (UI Configuration & Safety)

### P1: Dashboard UI for ArchGW Configuration

- [ ] Backend API endpoints created for ArchGW configuration (GET, PUT)
- [ ] Frontend component created: ArchGWConfig.tsx (configuration UI)
- [ ] Provider management UI: Add/edit/remove providers with API key inputs
- [ ] Preference configuration UI: Dropdowns for global and per-subagent preferences
- [ ] Routing rules UI: Table showing subagent → model mappings with edit capability
- [ ] Instance management UI: Add/remove ArchGW instances for load balancing
- [ ] Failover settings UI: Configure max retries, backoff strategy, preference degradation
- [ ] Live testing UI: Input sample request, see routing decision and response
- [ ] Form validation: Required fields, valid URLs, API key format
- [ ] Configuration changes saved to config.yaml (or separate archgw_config.yaml)
- [ ] Real-time preview of configuration changes before saving
- [ ] Success/error notifications for configuration updates
- [ ] Unit tests for frontend components (Vitest)
- [ ] Integration tests for backend API endpoints
- [ ] Documentation updated with UI screenshots and usage guide

### P2: Guardrails Integration

- [ ] Guardrails enabled in plano_config.yaml
- [ ] Guardrail policies configured (jailbreak detection, content moderation)
- [ ] ArchGW guardrail responses parsed and logged
- [ ] Blocked requests logged with guardrail reason
- [ ] Dashboard displays guardrail events (blocked requests, warnings)
- [ ] Dashboard component: GuardrailEvents.tsx (event log, statistics)
- [ ] Guardrail statistics tracked (blocks per category, warning rate)
- [ ] Configuration UI for enabling/disabling guardrails
- [ ] Configuration UI for setting guardrail policies (block vs warn)
- [ ] Unit tests for guardrail response parsing
- [ ] Integration tests verify guardrail blocking behavior
- [ ] Documentation updated with guardrail configuration guide

---

## Sprint Scope Summary

### Sprint 1: Foundation (Phase 1)
**Delivers:** ArchGW local setup, basic provider integration, Docker deployment
**Deferred:** Advanced routing, dashboard UI, guardrails

### Sprint 2: Production Ready (Phase 2)
**Delivers:** Error handling, circuit breakers, fallback, monitoring
**Deferred:** Preference routing, dashboard UI, guardrails

### Sprint 3: Smart Routing (Phase 3)
**Delivers:** Preference-based routing, intelligent failover, load balancing
**Deferred:** Dashboard UI, guardrails

### Sprint 4: UI & Safety (Phase 4)
**Delivers:** Web UI for configuration, guardrails integration
**Deferred:** None (full integration complete)

---

## Overall Success Criteria

Integration is complete when:

1. **All phases delivered**: Phases 1-4 completed with all acceptance criteria met
2. **Core functionality preserved**: Anthropic passthrough unchanged, existing tests pass
3. **New providers accessible**: At least 3 new providers working through ArchGW (Gemini, Qwen, DeepSeek)
4. **Intelligent routing operational**: Preference-based routing optimizes for cost/speed/quality
5. **Resilience demonstrated**: Failover and circuit breakers prevent cascading failures
6. **UI functional**: Dashboard provides full configuration without editing YAML
7. **Safety enforced**: Guardrails block malicious requests with <5% false positive rate
8. **Performance acceptable**: ArchGW overhead <100ms, 90%+ uptime
9. **Documentation complete**: All configuration, usage, and troubleshooting documented
10. **Tests passing**: 100% of unit tests, integration tests, and E2E tests pass
