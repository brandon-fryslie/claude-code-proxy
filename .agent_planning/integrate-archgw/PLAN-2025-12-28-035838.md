# Complete ArchGW/Plano Integration Plan

**Generated:** 2025-12-28-035838
**Source:** STATUS-20251227_122421.md
**Topic:** integrate-archgw
**Scope:** Full integration including research, core features, dashboard, and guardrails

---

## Executive Summary

### Current State (from STATUS-20251227_122421.md)

The claude-code-proxy has a **fully functional provider routing system** with:
- Working Anthropic provider (passthrough, no format conversion)
- Working OpenAI provider (full Anthropic↔OpenAI format conversion)
- Subagent routing via prompt hashing (model_router.go)
- SQLite request logging (storage_sqlite.go)
- React dashboard for monitoring (web/)

**No ArchGW integration exists.** This is a greenfield integration spanning multiple phases.

### Integration Goals

Based on user requirements and STATUS analysis:

1. **Expanded Provider Support**: Access 11+ LLM providers through ArchGW (Gemini, Qwen, DeepSeek, Mistral, Groq, etc.)
2. **Preference-Based Routing**: Intelligent routing optimized for cost, speed, or quality using Arch-Router
3. **Multi-Provider Failover**: Resilience through automatic fallback when providers are unavailable
4. **Dashboard Integration**: Web UI for configuring ArchGW providers and routing preferences
5. **Guardrails**: Safety features including jailbreak detection and content moderation
6. **Preserve Core Constraints**: Anthropic passthrough remains unchanged, Go proxy is the front door

### Integration Architecture

ArchGW (now Plano) runs as a **sidecar service** alongside the Go proxy:

```
Client (Claude Code)
    |
    v
Go Proxy (port 3001) - Entry point, request logging, subagent detection
    |
    +-- Anthropic requests → Anthropic API (passthrough, unchanged)
    +-- OpenAI requests → OpenAI API (existing flow, unchanged)
    +-- ArchGW-routed requests → ArchGW Service → Multi-LLM routing
    |
    v
SQLite Logging + React Dashboard
```

**Key Design Principles:**
- ArchGW is **one provider among many**, not a replacement for the Go proxy
- Routing decision happens in ModelRouter (Go code controls when to use ArchGW)
- Format conversion handled by Go proxy (Anthropic → OpenAI before ArchGW)
- All requests logged to SQLite regardless of provider
- Dashboard provides unified view of all providers

### Total Gap

Comprehensive integration across 4 phases covering:

| Phase | Deliverables | Effort | Risk |
|-------|--------------|--------|------|
| Phase 1: Foundation | Research, local setup, basic provider | 4-6 days | LOW - Research validates feasibility |
| Phase 2: Core Integration | ArchGW provider, Docker Compose | 5-7 days | MEDIUM - Integration complexity |
| Phase 3: Advanced Routing | Preference routing, failover | 7-10 days | MEDIUM-HIGH - Complex routing logic |
| Phase 4: Dashboard & Guardrails | UI configuration, safety features | 6-9 days | MEDIUM - UI/backend coordination |

**Total Effort:** 22-32 days (complexity-based, not time-based)

---

## Phase 1: Foundation (Research & Basic Wiring)

**Goal:** Validate ArchGW integration feasibility and create basic provider implementation

**Status:** Not Started
**Total Effort:** Small-Medium (4-6 days complexity)
**Risk Level:** LOW

---

### [P0] ArchGW Research & Local Setup

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: User goals - "Expanded provider support" • **Status Reference**: STATUS-20251227_122421.md §"What ArchGW/Plano Offers"

#### Description

Get ArchGW/Plano running locally and understand its routing capabilities. Plano is a Rust/Envoy-based proxy that supports 11+ LLM providers. It accepts OpenAI-format requests and handles multi-provider routing.

**Key research areas:**
1. **Installation**: Docker vs Python CLI (`pip install planoai`)
2. **Configuration**: Provider setup in `plano_config.yaml`
3. **API Format**: Verify OpenAI `/v1/chat/completions` compatibility
4. **Routing Modes**: Model-based, alias-based, preference-aligned (Arch-Router)
5. **Response Format**: Confirm OpenAI-compatible streaming and non-streaming responses
6. **Performance**: Baseline latency measurements
7. **Guardrails**: Available safety features and configuration
8. **Error Handling**: Behavior when providers are down or unavailable

**Test criteria:**
- Successfully route requests through ArchGW to multiple providers (Gemini, Qwen, DeepSeek)
- Measure latency overhead of the ArchGW hop
- Verify streaming responses work correctly
- Test error scenarios (invalid model, provider down, timeout)

#### Acceptance Criteria

- [ ] ArchGW/Plano running locally via Docker Compose
- [ ] plano_config.yaml configured with at least 3 providers (Gemini, Qwen, DeepSeek)
- [ ] Test request successfully routed through ArchGW to Gemini using curl
- [ ] Test request successfully routed to Qwen and DeepSeek
- [ ] Streaming responses verified working for all 3 providers
- [ ] Non-streaming responses verified working
- [ ] Latency overhead measured and documented (target: <100ms for ArchGW hop)
- [ ] Error handling tested (invalid model returns clear error)
- [ ] Provider unavailability tested (ArchGW handles gracefully)
- [ ] Configuration patterns documented (provider setup, API keys, routing rules)
- [ ] Research document created: `.agent_planning/integrate-archgw/RESEARCH-archgw.md`

#### Technical Notes

**Installation options:**
```bash
# Option 1: Docker Compose (recommended)
docker-compose up

# Option 2: Python CLI (for development/testing)
pip install planoai
planoai up plano_config.yaml
```

**Test request pattern:**
```bash
# Model-based routing (direct)
curl http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{
    "model": "gemini-2.0-flash-exp",
    "messages": [{"role": "user", "content": "test"}],
    "stream": true
  }'

# Alias-based routing (semantic)
curl http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{
    "model": "fast-code-generation",  # Alias configured in plano_config.yaml
    "messages": [{"role": "user", "content": "test"}]
  }'
```

**Research outputs:**
- Document ArchGW's exact request/response format
- Note any deviations from OpenAI spec
- Identify which routing mode to use initially (likely model-based for Phase 1)
- Document preference routing setup (for Phase 3)
- List available guardrails and configuration options (for Phase 4)

---

### [P0] Design ArchGW Provider Integration

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 ArchGW Research completed
**Spec Reference**: CLAUDE.md §"Architecture" - Provider interface pattern • **Status Reference**: STATUS-20251227_122421.md §"Current Provider Support"

#### Description

Design how ArchGW will integrate into the existing provider architecture. The Go proxy currently has a Provider interface with two implementations (AnthropicProvider, OpenAIProvider). ArchGW will be a **third provider type**.

**Core Design Questions:**

1. **Provider Implementation Approach:**
   - Option A: Create new ArchGWProvider (custom implementation)
   - Option B: Reuse OpenAIProvider with archgw base_url
   - Recommendation: Custom ArchGWProvider for future flexibility (guardrails, preference routing config)

2. **Configuration Schema:**
   ```yaml
   providers:
     archgw:
       base_url: "http://localhost:8080"  # or http://archgw:8080 in Docker
       format: "openai"
       # ArchGW-specific fields
       routing_mode: "model"  # model | alias | preference
       enable_guardrails: false  # Phase 4
       preference_config:  # Phase 3
         optimize_for: "cost"  # cost | speed | quality
   ```

3. **Routing Decision Logic:**
   - When does ModelRouter route to ArchGW vs. direct providers?
   - Subagent mappings: `code-reviewer: "archgw:gemini-2.0-flash-exp"`
   - Model aliasing: `code-reviewer: "archgw:fast-code-generation"`
   - Default fallback behavior if ArchGW unavailable

4. **Format Conversion:**
   - Reuse existing OpenAI conversion from `openai.go`
   - Request: Anthropic → OpenAI (before sending to ArchGW)
   - Response: OpenAI → Anthropic (after receiving from ArchGW)
   - Streaming: SSE event transformation

5. **Error Handling:**
   - ArchGW service unavailable (connection refused)
   - Invalid model requested (404 from ArchGW)
   - Upstream provider timeout (504 from ArchGW)
   - Format conversion errors
   - Fallback strategy (fail request or retry with different provider?)

6. **Logging and Observability:**
   - Log original Anthropic request
   - Log converted OpenAI request sent to ArchGW
   - Log ArchGW routing decision (which provider/model used)
   - Log final response
   - Track ArchGW-specific metrics (routing time, provider selection)

#### Acceptance Criteria

- [ ] Design document created: `.agent_planning/integrate-archgw/DESIGN-archgw-provider.md`
- [ ] Provider implementation approach decided and documented
- [ ] Configuration schema defined for ArchGW provider in config.yaml
- [ ] Routing decision logic specified (when to route to ArchGW vs. direct providers)
- [ ] Error handling strategy documented (ArchGW down, model unavailable, timeout, etc.)
- [ ] Fallback behavior specified (fail vs. retry logic)
- [ ] Format conversion approach documented (reuse OpenAIProvider conversion)
- [ ] Integration points identified (files to modify, new files to create)
- [ ] Logging strategy defined (what to log at each stage)
- [ ] Future extensibility considered (Phase 3 preference routing, Phase 4 guardrails)

#### Technical Notes

**Existing provider pattern:**
```go
// proxy/internal/provider/provider.go
type Provider interface {
    Name() string
    ForwardRequest(ctx context.Context, req *http.Request) (*http.Response, error)
}
```

**Recommended ArchGW provider structure:**
```go
// proxy/internal/provider/archgw.go
type ArchGWProvider struct {
    name          string
    client        *http.Client
    config        *config.ProviderConfig
    routingMode   string  // "model" | "alias" | "preference"
    guardrails    bool
    fallbackProvider Provider  // Optional fallback
}

func (p *ArchGWProvider) ForwardRequest(ctx context.Context, req *http.Request) (*http.Response, error) {
    // 1. Convert Anthropic request to OpenAI format (reuse convertAnthropicToOpenAI)
    // 2. Add ArchGW-specific headers/routing hints if needed
    // 3. Forward to ArchGW base_url
    // 4. Handle streaming/non-streaming responses
    // 5. Convert OpenAI response back to Anthropic format
    // 6. Return response
}
```

**Routing logic in ModelRouter:**
```go
// proxy/internal/service/model_router.go
func (mr *ModelRouter) DetermineRoute(req *AnthropicRequest) RoutingDecision {
    // Existing logic: Check for subagent routing
    if subagentMatch := mr.matchSubagent(req); subagentMatch != nil {
        // Parse provider:model from subagent mapping
        providerName, targetModel := mr.parseMapping(subagentMatch.mapping)

        // NEW: If provider is "archgw", route to ArchGW provider
        if providerName == "archgw" {
            return RoutingDecision{
                Provider:      mr.providers["archgw"],
                ProviderName:  "archgw",
                TargetModel:   targetModel,  // Could be model name or alias
            }
        }
    }

    // Default: Route to Anthropic
    return defaultAnthropicRouting()
}
```

---

### [P1] Implement ArchGW Provider

**Status**: Not Started
**Effort**: Medium (3-5 days)
**Dependencies**: P0 Design completed, P0 Research completed
**Spec Reference**: CLAUDE.md §"Proxy Server" architecture • **Status Reference**: STATUS-20251227_122421.md §"Current Provider Support"

#### Description

Implement the ArchGW provider following the design from P0. This creates a new provider that fits into the existing provider architecture and enables routing requests through ArchGW to multiple LLM providers.

**Implementation scope:**
1. Create `proxy/internal/provider/archgw.go` implementing Provider interface
2. Update `config.yaml.example` with ArchGW example configuration
3. Update provider initialization in `cmd/proxy/main.go`
4. Update `model_router.go` to support routing to ArchGW provider
5. Implement OpenAI format conversion (reuse existing functions from openai.go)
6. Handle streaming and non-streaming responses
7. Implement error handling for ArchGW unavailability
8. Add comprehensive logging for ArchGW requests

**Test coverage:**
- Unit tests for ArchGW provider initialization
- Unit tests for request forwarding logic
- Unit tests for format conversion
- Integration tests for end-to-end routing (Claude Code → Go Proxy → ArchGW → Gemini)
- Error handling tests (ArchGW down, invalid model, timeout)
- Streaming response tests
- Logging verification tests

#### Acceptance Criteria

- [ ] ArchGWProvider implemented following Provider interface
- [ ] config.yaml.example updated with archgw provider example showing multiple models
- [ ] Provider initialization in main.go includes ArchGW provider
- [ ] Subagent mapping supports archgw provider (e.g., `code-reviewer: "archgw:gemini-2.0-flash-exp"`)
- [ ] Request format conversion working (Anthropic → OpenAI for ArchGW)
- [ ] Response format conversion working (OpenAI → Anthropic, streaming and non-streaming)
- [ ] Streaming SSE events correctly transformed through conversion pipeline
- [ ] Error handling implemented (ArchGW unavailable returns clear error)
- [ ] Error responses from ArchGW converted to Anthropic format
- [ ] Unit tests added for ArchGW provider (minimum 5 test cases)
- [ ] Integration test passes: curl to Go proxy → routes through ArchGW → returns valid response
- [ ] Existing tests still pass (Anthropic passthrough unchanged, OpenAI routing unchanged)
- [ ] SQLite logging captures ArchGW requests correctly (original request + ArchGW-routed request)
- [ ] Dashboard displays ArchGW requests with correct provider name
- [ ] Logging includes ArchGW routing decision (which model was selected)

#### Technical Notes

**Implementation pattern:**
```go
// proxy/internal/provider/archgw.go
package provider

import (
    "context"
    "net/http"
    "time"
    "github.com/brandon-fryslie/claude-code-proxy/proxy/internal/config"
)

type ArchGWProvider struct {
    name   string
    client *http.Client
    config *config.ProviderConfig
}

func NewArchGWProvider(name string, cfg *config.ProviderConfig) Provider {
    return &ArchGWProvider{
        name:   name,
        client: &http.Client{Timeout: 300 * time.Second},
        config: cfg,
    }
}

func (p *ArchGWProvider) Name() string {
    return p.name
}

func (p *ArchGWProvider) ForwardRequest(ctx context.Context, req *http.Request) (*http.Response, error) {
    // 1. Read Anthropic request body
    // 2. Convert to OpenAI format using convertAnthropicToOpenAI()
    // 3. Create new request to ArchGW base_url
    // 4. Forward request to ArchGW
    // 5. Check if streaming (Accept: text/event-stream)
    // 6. If streaming, transform SSE events using transformOpenAIStreamToAnthropic()
    // 7. If non-streaming, convert response using convertOpenAIToAnthropicResponse()
    // 8. Return response
}
```

**Config example:**
```yaml
providers:
  anthropic:
    base_url: "https://api.anthropic.com"
    format: "anthropic"

  archgw:
    base_url: "http://localhost:8080"
    format: "openai"

subagents:
  enable: true
  mappings:
    code-reviewer: "archgw:gemini-2.0-flash-exp"
    planner: "archgw:qwen-max"
    budget-agent: "archgw:deepseek-chat"
```

**Testing approach:**
```bash
# Unit tests
cd proxy && go test ./internal/provider/archgw_test.go -v

# Integration test
cd proxy && go test ./internal/service/integration_test.go -v -run TestArchGWIntegration

# E2E test with real ArchGW
docker-compose up -d archgw
cd proxy && go run cmd/proxy/main.go &
curl http://localhost:3001/v1/messages \
  -H "Content-Type: application/json" \
  -H "x-api-key: test" \
  -H "anthropic-version: 2023-06-01" \
  -d '{
    "model": "claude-3-5-sonnet-20241022",
    "max_tokens": 100,
    "system": [
      {"type": "text", "text": "You are Claude Code..."},
      {"type": "text", "text": "You are an elite code reviewer..."}
    ],
    "messages": [{"role": "user", "content": "Review this code"}]
  }'
```

**Gotchas:**
- ArchGW expects OpenAI format, so **must convert before forwarding**
- Must preserve streaming SSE format through conversion pipeline
- Error responses from ArchGW might be in OpenAI format, **need to convert to Anthropic format**
- Logging should capture **both** original Anthropic request and converted OpenAI request to ArchGW
- ArchGW may add custom headers or metadata in responses - verify compatibility

---

### [P2] Create Docker Compose Setup

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0 Research completed
**Spec Reference**: User goals - "Docker deployment acceptable" • **Status Reference**: STATUS-20251227_122421.md §"Deployment Constraints"

#### Description

Create a Docker Compose configuration that runs the Go proxy, ArchGW, and React dashboard as integrated services. This simplifies deployment and ensures ArchGW is available when the proxy starts.

**Services:**
1. `archgw` - ArchGW/Plano service
2. `proxy` - Go proxy server
3. `web` - React dashboard

**Networking:**
- Internal Docker network for service communication
- Proxy and web exposed to host
- ArchGW internal only (accessed via proxy)

**Configuration management:**
- Mount `config.yaml` into proxy container
- Mount `plano_config.yaml` into ArchGW container
- Environment variables for API keys
- Shared volume for SQLite database

#### Acceptance Criteria

- [ ] docker-compose.yaml created at repository root
- [ ] ArchGW service defined with correct image and configuration mount
- [ ] Proxy service defined with Dockerfile in proxy/
- [ ] Web service defined with Dockerfile in web/
- [ ] Proxy service configured to reference ArchGW via Docker network (http://archgw:8080)
- [ ] Environment variables documented in .env.example (API keys for providers)
- [ ] Volumes configured for persistent data (SQLite DB shared between proxy and web)
- [ ] Health checks added for all services
- [ ] Service dependencies configured (proxy depends_on archgw, web depends_on proxy)
- [ ] README.md updated with Docker Compose usage instructions
- [ ] Makefile updated with docker-up, docker-down, docker-logs commands
- [ ] Verified: `docker-compose up` starts all services successfully
- [ ] Verified: End-to-end request works through Docker setup (client → proxy → archgw → LLM)
- [ ] Verified: Dashboard accessible and displays requests correctly

#### Technical Notes

**Docker Compose structure:**
```yaml
version: '3.8'

services:
  archgw:
    image: katanemo/plano:latest  # Verify from research
    volumes:
      - ./plano_config.yaml:/etc/plano/config.yaml:ro
    networks:
      - proxy-net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 3
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - GEMINI_API_KEY=${GEMINI_API_KEY}

  proxy:
    build:
      context: ./proxy
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    volumes:
      - ./config.yaml:/app/config.yaml:ro
      - ./data:/app/data  # SQLite DB
    environment:
      - ARCHGW_BASE_URL=http://archgw:8080
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
    depends_on:
      archgw:
        condition: service_healthy
    networks:
      - proxy-net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 10s
      timeout: 5s
      retries: 3

  web:
    build:
      context: ./web
      dockerfile: Dockerfile
    ports:
      - "5173:5173"
    volumes:
      - ./data:/app/data  # Access same SQLite DB
    depends_on:
      proxy:
        condition: service_healthy
    networks:
      - proxy-net
    environment:
      - VITE_API_URL=http://proxy:3001

networks:
  proxy-net:
    driver: bridge

volumes:
  data:
```

**Makefile additions:**
```makefile
.PHONY: docker-up docker-down docker-logs docker-build

docker-build:
	docker-compose build

docker-up:
	docker-compose up -d

docker-down:
	docker-compose down

docker-logs:
	docker-compose logs -f

docker-restart:
	docker-compose restart
```

**.env.example:**
```bash
# Anthropic API (for direct passthrough)
ANTHROPIC_API_KEY=sk-ant-xxx

# OpenAI API (if using OpenAI provider directly)
OPENAI_API_KEY=sk-xxx

# Additional providers for ArchGW
GEMINI_API_KEY=xxx
QWEN_API_KEY=xxx
DEEPSEEK_API_KEY=xxx
```

---

## Phase 2: Core Integration (Production-Ready ArchGW)

**Goal:** Robust, production-ready ArchGW integration with comprehensive testing and monitoring

**Status:** Not Started
**Total Effort:** Medium (5-7 days complexity)
**Risk Level:** MEDIUM

---

### [P1] Comprehensive Error Handling & Fallback

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: Phase 1 P1 (Implement ArchGW Provider) completed
**Spec Reference**: User goals - "Multi-provider failover" • **Status Reference**: STATUS-20251227_122421.md §"Implementation Risks"

#### Description

Implement robust error handling and fallback logic for ArchGW integration. When ArchGW is unavailable or a specific provider fails, the system should gracefully handle errors and optionally fall back to alternative providers.

**Error scenarios to handle:**
1. ArchGW service unavailable (connection refused, timeout)
2. ArchGW returns 4xx error (invalid model, bad request)
3. ArchGW returns 5xx error (upstream provider failure)
4. ArchGW returns partial response (streaming interrupted)
5. Format conversion errors (malformed response)
6. Timeout exceeded (slow upstream provider)

**Fallback strategies:**
1. **No fallback** (default) - Return error to client with clear message
2. **Static fallback** - Configured alternative provider (e.g., archgw fails → openai)
3. **Dynamic fallback** - Intelligent provider selection based on error type
4. **Circuit breaker** - Temporarily disable ArchGW after repeated failures

#### Acceptance Criteria

- [ ] Error handling implemented for all ArchGW failure modes
- [ ] Clear error messages returned to client (include provider name, error type)
- [ ] Fallback configuration added to config.yaml (optional per provider)
- [ ] Circuit breaker pattern implemented (configurable thresholds)
- [ ] Circuit breaker state tracked and logged (open/closed/half-open)
- [ ] Fallback attempts logged separately in SQLite (original provider + fallback provider)
- [ ] Dashboard displays fallback events and circuit breaker state
- [ ] Unit tests for all error scenarios (minimum 8 test cases)
- [ ] Integration tests verify fallback behavior
- [ ] Metrics tracked: error rate per provider, fallback rate, circuit breaker trips
- [ ] Documentation updated with error handling configuration options

#### Technical Notes

**Config schema for fallback:**
```yaml
providers:
  archgw:
    base_url: "http://archgw:8080"
    format: "openai"
    fallback: "openai"  # Optional: fallback provider name
    circuit_breaker:
      enabled: true
      failure_threshold: 5  # Open circuit after 5 failures
      timeout: 60  # Stay open for 60 seconds
      half_open_requests: 3  # Allow 3 requests to test recovery
```

**Error handling pattern:**
```go
func (p *ArchGWProvider) ForwardRequest(ctx context.Context, req *http.Request) (*http.Response, error) {
    // Check circuit breaker state
    if p.circuitBreaker.IsOpen() {
        if p.config.Fallback != "" {
            return p.fallbackProvider.ForwardRequest(ctx, req)
        }
        return nil, fmt.Errorf("archgw circuit breaker open: %w", ErrServiceUnavailable)
    }

    // Attempt ArchGW request
    resp, err := p.doRequest(ctx, req)
    if err != nil {
        p.circuitBreaker.RecordFailure()

        // Log error
        log.Error("archgw request failed", "error", err, "circuit_state", p.circuitBreaker.State())

        // Attempt fallback if configured
        if p.config.Fallback != "" {
            log.Info("attempting fallback", "fallback_provider", p.config.Fallback)
            return p.fallbackProvider.ForwardRequest(ctx, req)
        }

        return nil, fmt.Errorf("archgw request failed: %w", err)
    }

    p.circuitBreaker.RecordSuccess()
    return resp, nil
}
```

**Circuit breaker implementation:**
```go
type CircuitBreaker struct {
    state            State  // Open, Closed, HalfOpen
    failureCount     int
    failureThreshold int
    timeout          time.Duration
    openedAt         time.Time
    halfOpenRequests int
    mu               sync.RWMutex
}

func (cb *CircuitBreaker) IsOpen() bool {
    cb.mu.RLock()
    defer cb.mu.RUnlock()

    if cb.state == Closed {
        return false
    }

    if cb.state == Open && time.Since(cb.openedAt) > cb.timeout {
        cb.state = HalfOpen
        return false
    }

    return cb.state == Open
}
```

---

### [P1] Enhanced Monitoring & Observability

**Status**: Not Started
**Effort**: Small-Medium (2-3 days)
**Dependencies**: Phase 1 P1 (Implement ArchGW Provider) completed
**Spec Reference**: CLAUDE.md §"Dashboard API" • **Status Reference**: STATUS-20251227_122421.md §"Current Provider Support"

#### Description

Extend the monitoring and observability system to capture ArchGW-specific metrics and routing decisions. The dashboard should provide visibility into ArchGW usage, provider distribution, and performance.

**New metrics to track:**
1. Requests per ArchGW provider (Gemini, Qwen, DeepSeek, etc.)
2. Latency breakdown (Go proxy overhead + ArchGW overhead + upstream provider)
3. Provider success/failure rates
4. Circuit breaker state changes
5. Fallback events and fallback success rates
6. Cost tracking per provider (if API provides cost data)

**Dashboard enhancements:**
1. ArchGW provider breakdown chart
2. Latency comparison across providers
3. Error rate trends per provider
4. Circuit breaker status indicators
5. Fallback event log

#### Acceptance Criteria

- [ ] SQLite schema extended to capture ArchGW-specific fields (provider, model, routing_mode)
- [ ] Request logging includes ArchGW routing decision (which provider/model selected)
- [ ] Latency tracking captures Go proxy overhead separately from ArchGW overhead
- [ ] New API endpoint: GET /api/stats/archgw (ArchGW-specific statistics)
- [ ] Dashboard component created: ArchGWStats.tsx (provider breakdown, latency, errors)
- [ ] Provider breakdown chart shows requests per ArchGW upstream provider
- [ ] Latency chart compares Anthropic vs OpenAI vs ArchGW providers
- [ ] Error rate chart shows success/failure per provider
- [ ] Circuit breaker status displayed in dashboard (open/closed/half-open)
- [ ] Fallback events logged and displayed in request details
- [ ] Dashboard automatically refreshes ArchGW stats every 30 seconds
- [ ] Documentation updated with new metrics and dashboard features

#### Technical Notes

**SQLite schema extension:**
```sql
ALTER TABLE requests ADD COLUMN archgw_provider TEXT;  -- "gemini", "qwen", etc.
ALTER TABLE requests ADD COLUMN archgw_model TEXT;  -- "gemini-2.0-flash-exp"
ALTER TABLE requests ADD COLUMN archgw_routing_mode TEXT;  -- "model", "alias", "preference"
ALTER TABLE requests ADD COLUMN proxy_latency_ms INTEGER;  -- Time in Go proxy
ALTER TABLE requests ADD COLUMN archgw_latency_ms INTEGER;  -- Time in ArchGW
ALTER TABLE requests ADD COLUMN upstream_latency_ms INTEGER;  -- Time in final provider
ALTER TABLE requests ADD COLUMN fallback_attempted BOOLEAN DEFAULT FALSE;
ALTER TABLE requests ADD COLUMN fallback_provider TEXT;
```

**New API endpoint:**
```go
// GET /api/stats/archgw?start=2025-12-27&end=2025-12-28
func (h *Handler) GetArchGWStats(w http.ResponseWriter, r *http.Request) {
    stats := h.storage.GetArchGWStats(startDate, endDate)

    // Return:
    // {
    //   "total_requests": 150,
    //   "providers": {
    //     "gemini": {"count": 80, "avg_latency_ms": 1200, "error_rate": 0.02},
    //     "qwen": {"count": 50, "avg_latency_ms": 900, "error_rate": 0.01},
    //     "deepseek": {"count": 20, "avg_latency_ms": 1500, "error_rate": 0.05}
    //   },
    //   "fallback_events": 5,
    //   "circuit_breaker_trips": 2
    // }
}
```

**Dashboard component:**
```typescript
// web/app/components/ArchGWStats.tsx
export function ArchGWStats({ dateRange }: { dateRange: DateRange }) {
  const { data, isLoading } = useArchGWStats(dateRange);

  if (isLoading) return <LoadingSpinner />;

  return (
    <div className="archgw-stats">
      <h2>ArchGW Provider Distribution</h2>
      <BarChart data={data.providers} />

      <h2>Latency by Provider</h2>
      <LineChart data={data.latency_by_provider} />

      <h2>Error Rates</h2>
      <PieChart data={data.error_rates} />

      <h2>Circuit Breaker Status</h2>
      <CircuitBreakerIndicator state={data.circuit_breaker_state} />
    </div>
  );
}
```

---

## Phase 3: Advanced Routing (Preference & Optimization)

**Goal:** Intelligent routing based on preferences (cost/speed/quality) and multi-provider failover

**Status:** Not Started
**Total Effort:** Medium-Large (7-10 days complexity)
**Risk Level:** MEDIUM-HIGH

---

### [P1] Preference-Based Routing Configuration

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: Phase 2 complete
**Spec Reference**: User goals - "Preference routing: Cost/speed/quality optimization" • **Status Reference**: STATUS-20251227_122421.md §"Plano Routing Features"

#### Description

Implement configuration and infrastructure for preference-based routing using ArchGW's Arch-Router feature. Arch-Router is a 1.5B parameter model that routes requests based on context and user preferences (cost, speed, quality).

**Routing preferences:**
1. **Cost-optimized**: Route to cheapest provider that meets quality threshold
2. **Speed-optimized**: Route to fastest provider (lowest latency)
3. **Quality-optimized**: Route to highest-quality provider (best model performance)
4. **Balanced**: Weighted combination of cost, speed, quality

**Configuration levels:**
1. **Global default**: Apply to all requests unless overridden
2. **Per-subagent**: Specific preferences for each subagent
3. **Per-request**: Override via request metadata (advanced)

**Implementation approach:**
1. Extend config schema to support preference routing
2. Pass preferences to ArchGW via request headers or model alias
3. Parse ArchGW response to capture routing decision
4. Log routing decision for observability

#### Acceptance Criteria

- [ ] Config schema extended with preference routing options
- [ ] Global preference setting supported (optimize_for: cost/speed/quality/balanced)
- [ ] Per-subagent preference override supported
- [ ] Preferences passed to ArchGW correctly (via headers or model alias)
- [ ] ArchGW routing decision captured in response metadata
- [ ] Routing decision logged to SQLite (selected_provider, routing_reason)
- [ ] Dashboard displays routing decisions and preference effectiveness
- [ ] Documentation created: `.agent_planning/integrate-archgw/PREFERENCES.md`
- [ ] Unit tests for preference configuration parsing
- [ ] Integration tests verify correct provider selection based on preferences
- [ ] A/B testing support: Compare cost savings vs. quality impact

#### Technical Notes

**Config schema for preferences:**
```yaml
providers:
  archgw:
    base_url: "http://archgw:8080"
    format: "openai"
    routing_mode: "preference"  # Enable Arch-Router
    preferences:
      default: "cost"  # cost | speed | quality | balanced
      weights:  # For "balanced" mode
        cost: 0.4
        speed: 0.3
        quality: 0.3

subagents:
  mappings:
    # Model-based routing (Phase 1)
    code-reviewer: "archgw:gemini-2.0-flash-exp"

    # Preference-based routing (Phase 3)
    planner: "archgw:preference:cost"  # Use cost-optimized routing
    security-auditor: "archgw:preference:quality"  # Use quality-optimized routing
    quick-responder: "archgw:preference:speed"  # Use speed-optimized routing
```

**Passing preferences to ArchGW:**
```go
func (p *ArchGWProvider) buildArchGWRequest(anthropicReq *AnthropicRequest, preference string) *http.Request {
    openaiReq := convertAnthropicToOpenAI(anthropicReq)

    // Option 1: Use ArchGW's preference routing endpoint
    url := fmt.Sprintf("%s/v1/chat/completions?preference=%s", p.config.BaseURL, preference)

    // Option 2: Use model alias configured in plano_config.yaml
    // openaiReq.Model = fmt.Sprintf("preference-%s", preference)

    // Option 3: Add custom header
    req.Header.Set("X-ArchGW-Preference", preference)

    return req
}
```

**ArchGW routing decision capture:**
```go
// ArchGW may include routing metadata in response headers
func (p *ArchGWProvider) parseRoutingDecision(resp *http.Response) RoutingMetadata {
    return RoutingMetadata{
        SelectedProvider: resp.Header.Get("X-ArchGW-Provider"),  // e.g., "gemini"
        SelectedModel:    resp.Header.Get("X-ArchGW-Model"),     // e.g., "gemini-2.0-flash-exp"
        RoutingReason:    resp.Header.Get("X-ArchGW-Reason"),    // e.g., "cost-optimized"
        RoutingScore:     resp.Header.Get("X-ArchGW-Score"),     // Confidence score
    }
}
```

**Logging routing decisions:**
```go
func (s *SQLiteStorage) LogRequest(req RequestLog) error {
    // Existing fields + new fields for routing decision
    _, err := s.db.Exec(`
        INSERT INTO requests (
            ...,
            archgw_provider,
            archgw_model,
            routing_preference,
            routing_reason,
            routing_score
        ) VALUES (?, ?, ?, ?, ?, ...)
    `, ..., req.ArchGWProvider, req.ArchGWModel, req.RoutingPreference, req.RoutingReason, req.RoutingScore)

    return err
}
```

---

### [P2] Intelligent Failover & Load Balancing

**Status**: Not Started
**Effort**: Medium-Large (4-6 days)
**Dependencies**: P1 Preference Routing completed
**Spec Reference**: User goals - "Multi-provider failover" • **Status Reference**: STATUS-20251227_122421.md §"Integration Analysis"

#### Description

Implement intelligent failover that automatically retries failed requests with alternative providers while respecting preference constraints. Also implement load balancing across multiple ArchGW instances for scalability.

**Failover strategies:**
1. **Preference-preserving**: Retry with next-best provider matching preference (e.g., if cost-optimized provider fails, try second-cheapest)
2. **Degraded mode**: Relax preference constraint on retry (e.g., try speed-optimized if cost-optimized fails)
3. **Best-effort**: Try any available provider on final retry

**Load balancing:**
1. Support multiple ArchGW instances for horizontal scaling
2. Round-robin or least-connections distribution
3. Health-aware routing (skip unhealthy instances)

#### Acceptance Criteria

- [ ] Failover logic implemented for ArchGW provider failures
- [ ] Retry attempts configurable (max_retries, backoff strategy)
- [ ] Preference-preserving retry logic implemented
- [ ] Degraded mode retry implemented (relax preferences on retry)
- [ ] Multiple ArchGW instances supported in configuration
- [ ] Load balancing strategy configurable (round-robin, least-connections)
- [ ] Health checks for ArchGW instances (mark unhealthy instances)
- [ ] Retry attempts logged separately (initial + retries)
- [ ] Dashboard displays retry statistics and success rates
- [ ] Unit tests for failover logic (minimum 6 scenarios)
- [ ] Integration tests verify end-to-end failover behavior
- [ ] Performance tests validate load balancing distribution

#### Technical Notes

**Config schema for failover:**
```yaml
providers:
  archgw:
    instances:
      - url: "http://archgw-1:8080"
      - url: "http://archgw-2:8080"
      - url: "http://archgw-3:8080"
    load_balancing: "round-robin"  # round-robin | least-connections | random
    failover:
      max_retries: 3
      backoff: "exponential"  # exponential | linear | constant
      initial_delay_ms: 100
      max_delay_ms: 5000
      degrade_preferences: true  # Relax preferences on retry
```

**Failover logic:**
```go
func (p *ArchGWProvider) ForwardRequestWithRetry(ctx context.Context, req *http.Request, preference string) (*http.Response, error) {
    var lastErr error
    currentPreference := preference

    for attempt := 0; attempt <= p.config.Failover.MaxRetries; attempt++ {
        // Select ArchGW instance (load balancing)
        instance := p.selectInstance()

        // Attempt request
        resp, err := p.doRequest(ctx, req, instance, currentPreference)
        if err == nil {
            return resp, nil
        }

        lastErr = err
        log.Warn("archgw request failed, retrying",
            "attempt", attempt+1,
            "preference", currentPreference,
            "error", err)

        // Degrade preference on retry if configured
        if p.config.Failover.DegradePreferences && attempt > 0 {
            currentPreference = p.degradePreference(currentPreference)
        }

        // Backoff before retry
        time.Sleep(p.calculateBackoff(attempt))
    }

    return nil, fmt.Errorf("archgw request failed after %d retries: %w", p.config.Failover.MaxRetries, lastErr)
}

func (p *ArchGWProvider) degradePreference(pref string) string {
    // Preference degradation hierarchy:
    // cost → balanced → speed → quality → best-effort
    switch pref {
    case "cost":
        return "balanced"
    case "balanced":
        return "speed"
    case "speed":
        return "quality"
    default:
        return "best-effort"  // Try any available provider
    }
}
```

**Load balancing:**
```go
type ArchGWInstancePool struct {
    instances []*ArchGWInstance
    strategy  LoadBalancingStrategy
    index     int  // For round-robin
    mu        sync.Mutex
}

func (pool *ArchGWInstancePool) selectInstance() *ArchGWInstance {
    pool.mu.Lock()
    defer pool.mu.Unlock()

    switch pool.strategy {
    case RoundRobin:
        instance := pool.instances[pool.index]
        pool.index = (pool.index + 1) % len(pool.instances)
        return instance

    case LeastConnections:
        return pool.findLeastConnections()

    case Random:
        return pool.instances[rand.Intn(len(pool.instances))]

    default:
        return pool.instances[0]
    }
}
```

---

## Phase 4: Dashboard & Guardrails (UI Configuration & Safety)

**Goal:** Web UI for ArchGW configuration and safety features via guardrails

**Status:** Not Started
**Total Effort:** Medium (6-9 days complexity)
**Risk Level:** MEDIUM

---

### [P1] Dashboard UI for ArchGW Configuration

**Status**: Not Started
**Effort**: Medium-Large (4-6 days)
**Dependencies**: Phase 3 complete
**Spec Reference**: CLAUDE.md §"Web Dashboard" • **Status Reference**: STATUS-20251227_122421.md §"Web Dashboard"

#### Description

Create web UI components for configuring ArchGW providers, preferences, and routing rules. This provides a user-friendly alternative to editing config.yaml manually.

**UI features:**
1. **Provider Management**: Add/edit/remove ArchGW providers, set API keys
2. **Preference Configuration**: Set global and per-subagent preferences (cost/speed/quality)
3. **Routing Rules**: Configure subagent → ArchGW model mappings
4. **Instance Management**: Configure multiple ArchGW instances for load balancing
5. **Failover Settings**: Configure retry behavior, backoff, preference degradation
6. **Live Testing**: Test ArchGW routing with sample requests

**Backend API:**
- GET /api/config/archgw - Get current ArchGW configuration
- PUT /api/config/archgw - Update ArchGW configuration
- POST /api/test/archgw - Test ArchGW routing with sample request

#### Acceptance Criteria

- [ ] Backend API endpoints created for ArchGW configuration (GET, PUT)
- [ ] Frontend component created: ArchGWConfig.tsx (configuration UI)
- [ ] Provider management UI: Add/edit/remove providers with API key inputs
- [ ] Preference configuration UI: Dropdowns for global and per-subagent preferences
- [ ] Routing rules UI: Table showing subagent → model mappings with edit capability
- [ ] Instance management UI: Add/remove ArchGW instances for load balancing
- [ ] Failover settings UI: Configure max retries, backoff strategy, preference degradation
- [ ] Live testing UI: Input sample request, see routing decision and response
- [ ] Form validation: Required fields, valid URLs, API key format
- [ ] Configuration changes saved to config.yaml (or separate archgw_config.yaml)
- [ ] Real-time preview of configuration changes before saving
- [ ] Success/error notifications for configuration updates
- [ ] Unit tests for frontend components (Vitest)
- [ ] Integration tests for backend API endpoints
- [ ] Documentation updated with UI screenshots and usage guide

#### Technical Notes

**Backend API:**
```go
// GET /api/config/archgw
func (h *Handler) GetArchGWConfig(w http.ResponseWriter, r *http.Request) {
    config := h.configService.GetArchGWConfig()
    json.NewEncoder(w).Encode(config)
}

// PUT /api/config/archgw
func (h *Handler) UpdateArchGWConfig(w http.ResponseWriter, r *http.Request) {
    var newConfig ArchGWConfig
    if err := json.NewDecoder(r.Body).Decode(&newConfig); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Validate configuration
    if err := h.configService.ValidateArchGWConfig(newConfig); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    // Save to config file
    if err := h.configService.UpdateArchGWConfig(newConfig); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // Reload configuration (hot reload)
    h.configService.Reload()

    w.WriteHeader(http.StatusOK)
}

// POST /api/test/archgw
func (h *Handler) TestArchGWRouting(w http.ResponseWriter, r *http.Request) {
    var testReq TestRoutingRequest
    json.NewDecoder(r.Body).Decode(&testReq)

    // Execute routing with test request
    result := h.archgwProvider.TestRouting(testReq)

    json.NewEncoder(w).Encode(result)
}
```

**Frontend component structure:**
```typescript
// web/app/components/ArchGWConfig.tsx
export function ArchGWConfig() {
  const [config, setConfig] = useState<ArchGWConfig | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [testRequest, setTestRequest] = useState('');
  const [testResult, setTestResult] = useState<TestResult | null>(null);

  // Load configuration
  useEffect(() => {
    fetch('/api/config/archgw')
      .then(res => res.json())
      .then(setConfig);
  }, []);

  const handleSave = async () => {
    await fetch('/api/config/archgw', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config),
    });
    setIsEditing(false);
  };

  const handleTest = async () => {
    const result = await fetch('/api/test/archgw', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ request: testRequest }),
    }).then(res => res.json());
    setTestResult(result);
  };

  return (
    <div className="archgw-config">
      <h1>ArchGW Configuration</h1>

      <section className="providers">
        <h2>Providers</h2>
        <ProviderList
          providers={config?.providers}
          onUpdate={(providers) => setConfig({...config, providers})}
        />
      </section>

      <section className="preferences">
        <h2>Routing Preferences</h2>
        <PreferenceConfig
          preferences={config?.preferences}
          onUpdate={(preferences) => setConfig({...config, preferences})}
        />
      </section>

      <section className="routing-rules">
        <h2>Routing Rules</h2>
        <RoutingRulesTable
          rules={config?.subagents?.mappings}
          onUpdate={(mappings) => setConfig({...config, subagents: {...config.subagents, mappings}})}
        />
      </section>

      <section className="test">
        <h2>Test Routing</h2>
        <textarea value={testRequest} onChange={(e) => setTestRequest(e.target.value)} />
        <button onClick={handleTest}>Test</button>
        {testResult && <TestResultDisplay result={testResult} />}
      </section>

      <button onClick={handleSave} disabled={!isEditing}>Save Configuration</button>
    </div>
  );
}
```

---

### [P2] Guardrails Integration

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: P1 Dashboard UI completed
**Spec Reference**: User goals - "Guardrails integration" • **Status Reference**: STATUS-20251227_122421.md §"Additional Plano Features"

#### Description

Integrate ArchGW's guardrails features for content safety and jailbreak detection. Guardrails analyze requests and responses to detect and block potentially harmful content.

**Guardrail features:**
1. **Jailbreak detection**: Detect attempts to bypass model safety guidelines
2. **Content moderation**: Filter inappropriate or harmful content
3. **PII detection**: Identify and optionally redact personally identifiable information
4. **Custom filters**: User-defined content filters

**Integration points:**
1. Enable guardrails in ArchGW configuration
2. Configure guardrail policies (block, warn, log)
3. Capture guardrail decisions in request logs
4. Display guardrail events in dashboard

#### Acceptance Criteria

- [ ] Guardrails enabled in plano_config.yaml
- [ ] Guardrail policies configured (jailbreak detection, content moderation)
- [ ] ArchGW guardrail responses parsed and logged
- [ ] Blocked requests logged with guardrail reason
- [ ] Dashboard displays guardrail events (blocked requests, warnings)
- [ ] Dashboard component: GuardrailEvents.tsx (event log, statistics)
- [ ] Guardrail statistics tracked (blocks per category, warning rate)
- [ ] Configuration UI for enabling/disabling guardrails
- [ ] Configuration UI for setting guardrail policies (block vs warn)
- [ ] Unit tests for guardrail response parsing
- [ ] Integration tests verify guardrail blocking behavior
- [ ] Documentation updated with guardrail configuration guide

#### Technical Notes

**ArchGW guardrails configuration (plano_config.yaml):**
```yaml
guardrails:
  enabled: true
  policies:
    jailbreak_detection:
      action: "block"  # block | warn | log
      sensitivity: "medium"  # low | medium | high

    content_moderation:
      action: "warn"
      categories:
        - "violence"
        - "hate_speech"
        - "sexual_content"

    pii_detection:
      action: "log"
      redact: false  # Redact PII from logs if true
      types:
        - "email"
        - "phone"
        - "ssn"
        - "credit_card"
```

**Parsing guardrail responses:**
```go
type GuardrailDecision struct {
    Action   string  `json:"action"`   // "blocked" | "warned" | "allowed"
    Category string  `json:"category"` // "jailbreak" | "content_moderation" | "pii"
    Reason   string  `json:"reason"`   // Human-readable explanation
    Score    float64 `json:"score"`    // Confidence score
}

func (p *ArchGWProvider) parseGuardrailResponse(resp *http.Response) (*GuardrailDecision, error) {
    // ArchGW may return guardrail decision in response headers or body
    if resp.StatusCode == 403 && resp.Header.Get("X-ArchGW-Guardrail") != "" {
        return &GuardrailDecision{
            Action:   "blocked",
            Category: resp.Header.Get("X-ArchGW-Guardrail-Category"),
            Reason:   resp.Header.Get("X-ArchGW-Guardrail-Reason"),
        }, nil
    }

    return nil, nil  // No guardrail triggered
}
```

**Logging guardrail events:**
```sql
-- Add guardrail fields to requests table
ALTER TABLE requests ADD COLUMN guardrail_action TEXT;  -- "blocked" | "warned" | NULL
ALTER TABLE requests ADD COLUMN guardrail_category TEXT;
ALTER TABLE requests ADD COLUMN guardrail_reason TEXT;
ALTER TABLE requests ADD COLUMN guardrail_score REAL;
```

**Dashboard component:**
```typescript
// web/app/components/GuardrailEvents.tsx
export function GuardrailEvents({ dateRange }: { dateRange: DateRange }) {
  const { data, isLoading } = useGuardrailEvents(dateRange);

  return (
    <div className="guardrail-events">
      <h2>Guardrail Events</h2>

      <div className="stats">
        <StatCard label="Blocked Requests" value={data.blocked_count} />
        <StatCard label="Warnings" value={data.warning_count} />
        <StatCard label="Block Rate" value={`${data.block_rate}%`} />
      </div>

      <div className="category-breakdown">
        <h3>Events by Category</h3>
        <BarChart data={data.events_by_category} />
      </div>

      <div className="event-log">
        <h3>Recent Events</h3>
        <table>
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Action</th>
              <th>Category</th>
              <th>Reason</th>
              <th>Request ID</th>
            </tr>
          </thead>
          <tbody>
            {data.events.map(event => (
              <tr key={event.id}>
                <td>{formatTimestamp(event.timestamp)}</td>
                <td><Badge color={event.action === 'blocked' ? 'red' : 'yellow'}>{event.action}</Badge></td>
                <td>{event.category}</td>
                <td>{event.reason}</td>
                <td><Link to={`/requests/${event.request_id}`}>{event.request_id}</Link></td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}
```

---

## Dependency Graph

```
Phase 1: Foundation
├── P0: ArchGW Research
│   ├── → P0: Design ArchGW Provider
│   └── → P2: Docker Compose Setup
├── P0: Design ArchGW Provider
│   └── → P1: Implement ArchGW Provider
└── P1: Implement ArchGW Provider
    └── → Phase 2

Phase 2: Core Integration
├── P1: Comprehensive Error Handling
│   └── → Phase 3
└── P1: Enhanced Monitoring
    └── → Phase 3

Phase 3: Advanced Routing
├── P1: Preference Routing
│   └── → P2: Intelligent Failover
└── P2: Intelligent Failover
    └── → Phase 4

Phase 4: Dashboard & Guardrails
├── P1: Dashboard UI
│   └── → P2: Guardrails Integration
└── P2: Guardrails Integration
    └── → COMPLETE
```

**Critical Path:**
1. Phase 1 P0 Research → P0 Design → P1 Implement
2. Phase 2 P1 Error Handling
3. Phase 3 P1 Preference Routing → P2 Failover
4. Phase 4 P1 Dashboard UI → P2 Guardrails

**Parallel Work Opportunities:**
- Phase 1: P2 Docker Compose can be done alongside P1 Implement
- Phase 2: Error Handling and Monitoring can be done in parallel
- Phase 4: Dashboard UI and Guardrails can be partially parallelized (UI framework first, then guardrails integration)

---

## Risk Assessment

### Critical Risks (HIGH Impact)

| Risk | Impact | Mitigation | Phase |
|------|--------|------------|-------|
| ArchGW format incompatibility | BLOCKS integration | Phase 1 P0 Research validates early | 1 |
| Breaking Anthropic passthrough | CRITICAL - violates core constraint | Comprehensive tests, separate code paths | 1-2 |
| Performance regression | User-visible latency | Measure in Phase 1, set acceptable thresholds | 1-2 |
| Preference routing doesn't work as expected | Phase 3 blocked | Validate Arch-Router behavior in Phase 1 research | 3 |

### Medium Risks (MEDIUM Impact)

| Risk | Impact | Mitigation | Phase |
|------|--------|------------|-------|
| ArchGW deployment complexity | Adoption friction | Docker Compose simplifies, document troubleshooting | 1 |
| Config management complexity | Developer friction | UI in Phase 4, sensible defaults, validation | 4 |
| Circuit breaker tuning | False positives/negatives | Make thresholds configurable, provide guidance | 2 |
| Guardrails false positives | Blocks legitimate requests | Configurable sensitivity, warn mode | 4 |

### Low Risks (LOW Impact)

| Risk | Impact | Mitigation | Phase |
|------|--------|------------|-------|
| OpenAI conversion reuse | Implementation delay | Code already tested | 1 |
| SQLite schema changes | Data migration | Use ALTER TABLE, backward compatible | 2-4 |
| Dashboard UI complexity | Development time | Reuse existing components, iterative approach | 4 |

---

## Success Metrics

### Phase 1: Foundation
- [ ] ArchGW running locally via Docker Compose
- [ ] At least 3 providers configured (Gemini, Qwen, DeepSeek)
- [ ] End-to-end request: Client → Go Proxy → ArchGW → Gemini
- [ ] Latency overhead <100ms for ArchGW hop
- [ ] All existing tests pass (Anthropic passthrough unchanged)

### Phase 2: Core Integration
- [ ] Circuit breaker prevents cascading failures
- [ ] Fallback provider works when ArchGW unavailable
- [ ] Dashboard displays ArchGW requests with provider breakdown
- [ ] Error rate per provider tracked and displayed
- [ ] 90%+ uptime for ArchGW integration

### Phase 3: Advanced Routing
- [ ] Preference routing routes to correct providers (cost/speed/quality)
- [ ] Cost-optimized routing measurably reduces API costs (10%+ savings)
- [ ] Intelligent failover preserves preferences on retry
- [ ] Load balancing distributes requests across ArchGW instances

### Phase 4: Dashboard & Guardrails
- [ ] Web UI allows full ArchGW configuration without editing YAML
- [ ] Live testing validates routing decisions before deployment
- [ ] Guardrails block jailbreak attempts (0 false negatives in testing)
- [ ] Guardrail false positive rate <5%
- [ ] Dashboard provides clear visibility into all ArchGW features

---

## Testing Strategy

### Unit Tests (Per Phase)

**Phase 1:**
- Provider initialization
- Request format conversion (Anthropic → OpenAI)
- Response format conversion (OpenAI → Anthropic)
- Streaming SSE transformation
- Routing decision logic

**Phase 2:**
- Error handling for all failure modes
- Circuit breaker state transitions
- Fallback provider selection
- Logging ArchGW-specific fields

**Phase 3:**
- Preference configuration parsing
- Preference-based provider selection
- Failover with preference degradation
- Load balancing distribution

**Phase 4:**
- Configuration API validation
- Guardrail response parsing
- UI form validation

### Integration Tests (Per Phase)

**Phase 1:**
- End-to-end: curl → Go Proxy → ArchGW → Gemini
- Streaming responses work correctly
- SQLite logging captures ArchGW requests

**Phase 2:**
- Circuit breaker opens after threshold failures
- Fallback provider used when ArchGW down
- Dashboard displays correct statistics

**Phase 3:**
- Cost-optimized routing selects cheapest provider
- Speed-optimized routing selects fastest provider
- Failover preserves preferences

**Phase 4:**
- Configuration changes via UI persist to config file
- Guardrails block malicious requests
- Dashboard displays guardrail events

### E2E Tests (Final Validation)

- Full workflow: Claude Code → Go Proxy → ArchGW → Multiple Providers
- Dashboard displays all metrics correctly
- Configuration changes via UI apply immediately
- Guardrails work in production-like environment

---

## Future Enhancements (Post-Phase 4)

These features are explicitly out of scope but may be considered later:

### OpenTelemetry Integration
- Distributed tracing across Go Proxy → ArchGW → LLM
- Metrics export to Prometheus/Grafana
- Performance dashboards

### Advanced Guardrails
- Custom content filters (user-defined patterns)
- Bias detection
- Toxicity scoring

### Cost Optimization
- Real-time cost tracking per request
- Budget alerts and throttling
- Cost attribution per subagent

### Multi-Tenancy
- Per-user or per-project ArchGW configurations
- Isolated guardrail policies
- Usage quotas

---

## Documentation Deliverables

Each phase will produce documentation:

### Phase 1
- `.agent_planning/integrate-archgw/RESEARCH-archgw.md` - Research findings
- `.agent_planning/integrate-archgw/DESIGN-archgw-provider.md` - Integration design
- Updated CLAUDE.md with ArchGW provider information

### Phase 2
- Error handling guide (fallback strategies, circuit breaker tuning)
- Monitoring and observability guide (metrics, dashboard)

### Phase 3
- `.agent_planning/integrate-archgw/PREFERENCES.md` - Preference routing guide
- Failover and load balancing configuration guide

### Phase 4
- UI configuration user guide with screenshots
- Guardrails configuration and best practices

---

## Recommended Sprint Planning

### Sprint 1: Foundation (Phase 1)
**Goal:** Validate feasibility and basic integration
**Deliverables:** P0 Research, P0 Design, P1 Implement, P2 Docker
**Duration:** 4-6 days complexity

### Sprint 2: Production Ready (Phase 2)
**Goal:** Robust error handling and monitoring
**Deliverables:** P1 Error Handling, P1 Monitoring
**Duration:** 5-7 days complexity

### Sprint 3: Smart Routing (Phase 3)
**Goal:** Preference-based routing and failover
**Deliverables:** P1 Preference Routing, P2 Failover
**Duration:** 7-10 days complexity

### Sprint 4: UI & Safety (Phase 4)
**Goal:** Dashboard and guardrails
**Deliverables:** P1 Dashboard UI, P2 Guardrails
**Duration:** 6-9 days complexity

---

## Blockers and Questions

### Open Questions
1. **Latency threshold**: What is the acceptable latency overhead for ArchGW routing? (Suggested: <100ms)
2. **Default providers**: Which providers should be configured by default in plano_config.yaml?
3. **Opt-in vs opt-out**: Should ArchGW be enabled by default or require explicit configuration?
4. **Cost tracking**: Should we track estimated costs per provider/request? (Requires provider pricing data)
5. **Guardrail strictness**: What should be the default guardrail sensitivity? (low/medium/high)

### Assumptions
- ArchGW/Plano Docker image is available and stable
- ArchGW API format matches OpenAI spec (validated in Phase 1 research)
- Preference routing (Arch-Router) is available in the version we deploy
- API keys for test providers (Gemini, Qwen, DeepSeek) can be obtained
- Docker deployment is acceptable for production use

### Dependencies
- External: ArchGW/Plano project must remain actively maintained
- External: Provider APIs must remain stable (Gemini, Qwen, etc.)
- Internal: Go proxy codebase must remain stable during integration
- Internal: Dashboard must support new ArchGW components

---

## Summary

This plan provides a **complete, phased integration of ArchGW** into the claude-code-proxy:

- **Phase 1** establishes the foundation and validates feasibility
- **Phase 2** makes the integration production-ready with error handling and monitoring
- **Phase 3** adds intelligent routing with preferences and failover
- **Phase 4** provides user-facing configuration UI and safety features

Each phase builds on the previous, allowing for incremental delivery and validation. The total effort is **22-32 days complexity** spread across 4 sprints.

**Next steps:**
1. Review and approve this plan
2. Answer open questions above
3. Begin Phase 1 Sprint 1 with P0 Research
