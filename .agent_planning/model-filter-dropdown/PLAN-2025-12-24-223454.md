# Sprint Plan: Model Filter Dropdown

**Generated**: 2025-12-24-223454
**Source**: STATUS-2025-12-24-164500.md
**Epic**: brandon-fryslie_claude-code-proxy-jx0
**Sprint Goal**: Add model and endpoint filtering to request list for faster navigation and analysis.

---

## Executive Summary

**Current State**: New dashboard has basic search but no model/endpoint filtering. Users cannot isolate requests by model type.

**Target State**: Dropdown filters for model (opus/sonnet/haiku) and endpoint type, matching old dashboard's filtering UI patterns.

**Total Items**: 3 work items (1 P0, 1 P1, 1 P2)

---

## Sprint Scope

### In Scope
- Model filter dropdown (all, opus, sonnet, haiku, or specific model strings)
- Endpoint filter dropdown (all, /v1/messages, /v1/models, etc.)
- Filter persistence across page navigation
- Combine filters with existing search functionality
- Update API calls to include filter params

### Out of Scope
- Advanced filtering (date ranges, token counts, response time) - separate epic
- Filter presets/saved filters
- Multi-select filters (single selection only for MVP)
- Provider filtering (can add later if needed)

### Dependencies
- Backend `/api/requests/summary` supports `model` query parameter
- Backend may need `endpoint` query parameter support (verify)

---

## Work Items

### [P0] Implement Model Filter Dropdown UI

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: None
**Spec Reference**: CLAUDE.md "Model Filtering" • **Status Reference**: STATUS-2025-12-24-164500.md Section "Feature Gap Analysis" line 121

#### Description
Create a dropdown component in the Requests page header that allows filtering by model type. Port UI pattern from old dashboard's model filter.

#### Acceptance Criteria
- [ ] Dropdown renders with options: "All Models", "Opus", "Sonnet", "Haiku"
- [ ] Selecting a model updates the request list to show only matching requests
- [ ] Selected filter displayed in dropdown (e.g., "Opus" selected shows "Opus" in button)
- [ ] Dropdown styled consistent with existing dashboard components
- [ ] Unit test: Selecting model triggers filter update

#### Technical Notes
- Reference: Old dashboard model filter pattern (search for `modelFilter` in `_index.tsx`)
- Use simple `<select>` for MVP, or Shadcn dropdown component for better UX
- Place next to existing search input in `PageHeader` actions
- Filter logic: Check if `request.model` contains "opus", "sonnet", or "haiku" (case-insensitive)

**Model Detection Logic**:
```tsx
function getModelType(model: string | undefined): string {
  if (!model) return 'unknown'
  const m = model.toLowerCase()
  if (m.includes('opus')) return 'opus'
  if (m.includes('sonnet')) return 'sonnet'
  if (m.includes('haiku')) return 'haiku'
  return 'other'
}
```

---

### [P1] Wire Model Filter to API Calls

**Status**: Not Started
**Effort**: Medium (1-2 days)
**Dependencies**: Model filter UI
**Spec Reference**: CLAUDE.md "Model Filtering" • **Status Reference**: STATUS-2025-12-24-164500.md Section "Data Flow Verification" line 334

#### Description
Update `useRequestsSummary` hook to accept model filter parameter and pass it to backend API. Ensure filtering happens server-side for efficiency.

#### Acceptance Criteria
- [ ] `useRequestsSummary` hook accepts `model` parameter (optional)
- [ ] When model filter selected, API call includes `?model=<model>` query param
- [ ] Backend returns only requests matching the model filter
- [ ] Client-side filtering removed (rely on backend filtering)
- [ ] TanStack Query cache invalidates when model filter changes

#### Technical Notes
- Reference: `web/app/routes/_index.tsx` lines 334-336 (model filter API call)
- Backend endpoint: `GET /api/requests/summary?model=opus&start=...&end=...`
- Verify backend supports partial model name matching (e.g., "opus" matches "claude-opus-4")
- Update query key to include model filter: `['requests', 'summary', { model, start, end }]`

**API Hook Pattern**:
```tsx
export function useRequestsSummary({
  model,
  start,
  end
}: {
  model?: string
  start?: string
  end?: string
}) {
  return useQuery({
    queryKey: ['requests', 'summary', { model, start, end }],
    queryFn: async () => {
      const url = new URL('/api/requests/summary', window.location.origin)
      if (model && model !== 'all') url.searchParams.set('model', model)
      if (start) url.searchParams.set('start', start)
      if (end) url.searchParams.set('end', end)
      const res = await fetch(url)
      if (!res.ok) throw new Error('Failed to fetch')
      return res.json()
    }
  })
}
```

---

### [P2] Add Endpoint Filter Dropdown

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: Model filter implementation
**Spec Reference**: None (enhancement) • **Status Reference**: STATUS-2025-12-24-164500.md Section "Feature Gap Analysis" (inferred need)

#### Description
Add a second dropdown to filter requests by endpoint type (e.g., /v1/messages, /v1/models). This helps users isolate main API requests from metadata requests.

#### Acceptance Criteria
- [ ] Dropdown renders with options: "All Endpoints", "/v1/messages", "/v1/models", etc.
- [ ] Selecting endpoint filters request list to show only matching requests
- [ ] Multiple filters work together (model + endpoint combine with AND logic)
- [ ] Endpoint filter persisted alongside model filter
- [ ] Backend supports `endpoint` query parameter (verify or implement)

#### Technical Notes
- Endpoints to support: `/v1/messages` (main), `/v1/models` (metadata), `/health` (monitoring)
- If backend doesn't support `endpoint` param, implement client-side filtering as fallback
- Place endpoint filter next to model filter in header
- Consider combining into single "Filters" dropdown with sections (stretch goal)

**Client-side Filter Fallback**:
```tsx
const filteredRequests = requests?.filter(r => {
  if (endpointFilter !== 'all' && r.endpoint !== endpointFilter) return false
  return true
})
```

---

## Dependency Graph

```
Model Filter UI (P0)
  └── Wire to API (P1)
        └── Endpoint Filter (P2)
```

**Critical Path**: Model Filter UI → API Integration

---

## Recommended Sprint Execution Order

1. **Day 1-2**: Build model filter dropdown UI component
2. **Day 3**: Wire model filter to API calls and verify backend support
3. **Day 4**: Add endpoint filter dropdown (if time permits)

**Total Sprint Duration**: 4 days (< 1 week)

---

## Risk Assessment

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| Backend doesn't support model filtering | Low | Medium | Verify API early, fall back to client-side filtering |
| Model name detection logic misses edge cases | Medium | Low | Test with actual request data, log unrecognized models |
| Too many filter options overwhelm UI | Low | Low | Start with basic options, add more based on user feedback |
| Filter state conflicts with search | Low | Medium | Clear design: filters AND search, not OR |

**Overall Risk**: LOW - Simple UI feature with proven backend support.

---

## Blockers and Questions

### Questions for User

1. **Endpoint filter priority**: Is endpoint filtering needed for MVP, or can it be deferred? (Recommend: defer if short on time)

2. **Model filter options**: Show specific model versions (e.g., "claude-opus-4.5") or just families (opus/sonnet/haiku)? (Recommend: families for simplicity)

3. **Filter persistence**: Persist filters in localStorage or URL params? (Recommend: URL params for shareable links)

### Blockers

None - verify backend supports `model` query parameter (likely already implemented based on old dashboard code).

---

## Testing Strategy

### Unit Tests
- Model filter dropdown renders with correct options
- Selecting filter updates component state
- Filter logic correctly identifies model types

### Integration Tests
- Model filter triggers API call with correct params
- Backend returns filtered results
- Multiple filters combine correctly (model + search)
- TanStack Query cache updates when filter changes

### E2E Tests
- User flow: Select "Opus" → see only opus requests → clear filter → see all
- Edge case: No requests match filter → show empty state

---

## Success Metrics

- Users can filter to specific model in <2 clicks (open dropdown + select)
- Filter reduces request list by expected amount (e.g., opus filter shows ~30% of requests)
- Filter state persists across page navigation
- No performance impact when filtering (same as unfiltered)

---

## Appendix: Code References

**Old Dashboard Files**:
- `web/app/routes/_index.tsx` search for `modelFilter` state variable
- `web/app/routes/_index.tsx` lines 334-336 (API call with model param)

**New Dashboard Files to Modify**:
- `dashboard/src/pages/Requests.tsx` (add filter dropdowns)
- `dashboard/src/lib/api.ts` (update useRequestsSummary hook)
- `dashboard/src/components/layout/PageHeader.tsx` (if filter goes in header)

**UI Component Libraries**:
- Consider Shadcn `Select` component for better UX: https://ui.shadcn.com/docs/components/select
- Or native `<select>` for simplicity
