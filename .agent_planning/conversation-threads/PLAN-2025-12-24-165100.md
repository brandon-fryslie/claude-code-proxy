# Sprint Plan: Conversation Threads

**Generated**: 2025-12-24-165100
**Source STATUS**: STATUS-2025-12-24-164500.md (dashboard-parity)
**Epic**: brandon-fryslie_claude-code-proxy-jaq

---

## Sprint Goal

Implement full conversation thread viewing with message bubbles, tool call visualization, and conversation flow analysis to provide context for individual requests within larger Claude Code sessions.

---

## Scope

### In Scope
- Conversation list view showing active sessions
- Full message thread display for selected conversation
- User/Assistant message bubbles with proper formatting
- Tool calls rendered inline with messages
- Tool results displayed with context
- Conversation metadata (session ID, project, message count, timespan)
- Message flow diagram showing conversation structure
- Expand/collapse sections for readability

### Out of Scope
- Editing or replaying conversations
- Creating new conversations from dashboard
- Real-time conversation updates (WebSocket)
- Conversation search/filtering
- Exporting conversations to other formats (Markdown, PDF)
- Conversation analytics (turn count, tool usage patterns)

---

## Current State (from STATUS)

**Old Dashboard** (`web/app/components/ConversationThread.tsx`):
- 202 LOC conversation display component
- Parses JSONL conversation logs from Claude Code
- Message bubbles for user/assistant turns
- Tool call visualization inline
- `MessageFlow.tsx` (281 LOC) for visual flow diagram
- Integrated with `/api/conversations` endpoint

**New Dashboard**:
- Conversations page exists but is minimal stub (187 LOC)
- No message thread parsing or display
- No tool call visualization
- Different conversation data structure (types mismatch)
- API endpoint exists but returns different format

---

## Work Items

### P0 - Conversation Data Model Alignment

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: None
**Spec Reference**: Old dashboard `ConversationThread.tsx` lines 6-36 • **Status Reference**: STATUS-2025-12-24-164500.md section "Open Questions #5"

#### Description
Align the conversation data model between backend API and frontend types. Ensure the new dashboard's conversation structure matches what the Go backend provides, or create adapter layer to transform old format to new.

#### Acceptance Criteria (REQUIRED)
- [ ] Backend `/api/conversations` endpoint response structure documented
- [ ] Frontend TypeScript types match backend JSON structure exactly
- [ ] Adapter function created if transformation needed (old → new format)
- [ ] Sample conversation data from backend validated against types
- [ ] Session metadata includes: sessionId, projectPath, projectName, startTime, endTime, messageCount
- [ ] Message structure includes: uuid, timestamp, role, content, tool calls, parent relationships
- [ ] Unit test: Adapter correctly transforms sample conversation data

#### Technical Notes
- Old format: JSONL with parentUuid, isSidechain, userType fields
- New format: May be simplified or restructured
- Check `proxy/internal/service/conversation.go` for backend structure
- Consider versioning if both formats need support

---

### P0 - Message Thread Display Component

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: Conversation Data Model Alignment
**Spec Reference**: Old dashboard `ConversationThread.tsx` lines 38-100 • **Status Reference**: STATUS-2025-12-24-164500.md section "Critical Gaps"

#### Description
Create message thread component that displays user and assistant messages in chronological order with chat bubble UI. Support rich message content including text, tool calls, and tool results. Handle turn boundaries and conversation flow.

#### Acceptance Criteria (REQUIRED)
- [ ] Messages displayed in chronological order (top to bottom or bottom to top)
- [ ] User messages styled differently from assistant messages (color/alignment)
- [ ] Each message shows timestamp and turn number
- [ ] Message content rendered with proper formatting (whitespace, code blocks)
- [ ] Tool calls displayed inline with assistant messages (not separate)
- [ ] Tool results displayed inline with assistant messages
- [ ] Long messages can be collapsed/expanded
- [ ] Conversation scrolls smoothly with 100+ messages
- [ ] Unit test: Component renders conversation with 10 messages correctly
- [ ] E2E test: Load conversation from API and verify all messages appear

#### Technical Notes
- Port UI patterns from old `ConversationThread.tsx`
- Reuse MessageContent component from message-content-parser sprint if available
- Consider virtualization for very long conversations (100+ messages)
- CSS: Use flexbox for message bubbles, distinct colors for user/assistant
- Handle edge cases: empty messages, system messages, multi-turn conversations

---

### P1 - Tool Call Visualization Inline

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: Message Thread Display Component
**Spec Reference**: Old dashboard `ToolUse.tsx` (208 LOC) + `ToolResult.tsx` (256 LOC) • **Status Reference**: STATUS-2025-12-24-164500.md section "Critical Gaps"

#### Description
Render tool calls and results inline with assistant messages in the conversation thread. Show tool name, input parameters, and result output with syntax highlighting. Support expandable/collapsible view for complex tool data.

#### Acceptance Criteria (REQUIRED)
- [ ] Tool call displays: tool name, input parameters (formatted JSON)
- [ ] Tool result displays: return value or error, execution status
- [ ] Tool calls visually distinct from message text (border, background, icon)
- [ ] Input parameters syntax-highlighted if code or JSON
- [ ] Result output syntax-highlighted if code or JSON
- [ ] Long inputs/results collapsed by default with expand button
- [ ] Multiple tool calls in same message displayed sequentially
- [ ] Error tool results highlighted (red border or warning icon)
- [ ] Unit test: Tool call component renders all fields correctly
- [ ] Unit test: Tool result component handles success and error cases

#### Technical Notes
- Port logic from `ToolUse.tsx` and `ToolResult.tsx`
- Reuse CodeViewer component if available for syntax highlighting
- Tool structure: `{ name, input: {...}, result: {...}, status }`
- Support tool types: Read, Write, Edit, Bash, Glob, Grep, etc.
- Anthropic API format: `content_block` with type `tool_use` or `tool_result`

---

### P1 - Conversation List View

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: Conversation Data Model Alignment
**Spec Reference**: Old dashboard `_index.tsx` conversations tab • **Status Reference**: STATUS-2025-12-24-164500.md section "Implemented Pages"

#### Description
Create conversation list showing all Claude Code sessions with summary information. Allow selection to view full thread. Display metadata like project name, message count, timespan, and last activity.

#### Acceptance Criteria (REQUIRED)
- [ ] List shows all conversations sorted by most recent first
- [ ] Each item displays: project name, session ID (truncated), message count, start/end time
- [ ] Click on conversation loads full message thread
- [ ] Visual indicator for active (ongoing) vs completed conversations
- [ ] Conversation duration displayed (e.g., "2h 15m")
- [ ] List loads quickly even with 50+ conversations (use summary endpoint)
- [ ] Empty state message when no conversations exist
- [ ] Unit test: List renders with sample conversation data
- [ ] E2E test: Click conversation item → full thread loads

#### Technical Notes
- Backend endpoint: `GET /api/conversations`
- Consider pagination if conversation count grows large (100+)
- Cache conversation summaries with TanStack Query
- UI pattern similar to request list (reuse styles)

---

### P2 - Message Flow Diagram

**Status**: Not Started
**Effort**: Medium (2-3 days)
**Dependencies**: Message Thread Display Component
**Spec Reference**: Old dashboard `MessageFlow.tsx` (281 LOC) • **Status Reference**: STATUS-2025-12-24-164500.md section "Advanced Gaps"

#### Description
Implement visual flow diagram showing conversation structure with branches, tool calls, and response chains. Provide bird's-eye view of conversation complexity and decision points.

#### Acceptance Criteria (REQUIRED)
- [ ] Flow diagram shows messages as nodes connected by edges
- [ ] User messages, assistant messages, tool calls visually distinct (shape/color)
- [ ] Parent-child relationships visible (lines connecting related messages)
- [ ] Branching shown for sidechain conversations (subagents)
- [ ] Click on node highlights corresponding message in thread
- [ ] Diagram auto-layouts for readability (no overlapping nodes)
- [ ] Zoom and pan controls for large conversations
- [ ] Toggle to show/hide flow diagram (default collapsed)
- [ ] Unit test: Flow graph correctly represents conversation structure
- [ ] E2E test: Load conversation with branching → diagram shows branches

#### Technical Notes
- Port from `MessageFlow.tsx` (281 LOC)
- Consider using `react-flow` or `cytoscape.js` for graph rendering
- Layout algorithm: hierarchical (top-down) or force-directed
- Handle complex cases: multiple subagents, deep nesting, loops
- Performance: May need to limit diagram to first 50 messages for very long conversations

---

### P2 - Conversation Metadata Panel

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: Message Thread Display Component
**Spec Reference**: Old dashboard `ConversationThread.tsx` lines 40-80 • **Status Reference**: STATUS-2025-12-24-164500.md (implied feature)

#### Description
Display conversation metadata in a dedicated panel or header section. Show session ID, project path, start/end times, total message count, tool usage summary, and other session-level information.

#### Acceptance Criteria (REQUIRED)
- [ ] Session ID displayed (full or truncated with copy button)
- [ ] Project name and path shown
- [ ] Start and end timestamps with duration calculation
- [ ] Total message count (user + assistant)
- [ ] Tool usage summary (e.g., "15 tool calls across 8 messages")
- [ ] Model information if available (primary model used)
- [ ] Metadata panel collapsible to save screen space
- [ ] Unit test: Metadata calculations (duration, message count) are accurate

#### Technical Notes
- Position at top of conversation view (sticky header)
- Calculate derived metrics from message array (don't duplicate in API)
- Tool usage summary: count unique tool names, total invocations
- Duration: `endTime - startTime` formatted as human-readable (e.g., "2h 15m 30s")

---

### P3 - Expand/Collapse All Messages

**Status**: Not Started
**Effort**: Small (1 day)
**Dependencies**: Message Thread Display Component
**Spec Reference**: Old dashboard pattern • **Status Reference**: STATUS-2025-12-24-164500.md (usability feature)

#### Description
Add controls to expand or collapse all messages in the thread simultaneously. Useful for long conversations where user wants to scan turn structure vs read full content.

#### Acceptance Criteria (REQUIRED)
- [ ] "Expand All" button shows full content for all messages
- [ ] "Collapse All" button shows only message headers (role + timestamp)
- [ ] Individual expand/collapse still works after global action
- [ ] State persists when switching between conversations (or resets, document behavior)
- [ ] Button states clear (don't show "Expand All" if all already expanded)
- [ ] Unit test: Expand/collapse state management correct for various scenarios

#### Technical Notes
- Use React state to track expanded message IDs (Set)
- "Expand All" → add all message IDs to set
- "Collapse All" → clear set
- Alternative: Expand/collapse by section (user messages, tool calls, etc.)

---

## Dependencies

### External Dependencies
- `react-flow` or similar graph library for message flow diagram (optional, can build custom)
- No new backend endpoints needed (uses existing `/api/conversations`)

### Internal Dependencies
- MessageContent component (from message-content-parser sprint)
- CodeViewer component (from code-viewer-highlighting sprint) for tool parameters/results
- ToolUse/ToolResult components (from tool-use-display, tool-result-display sprints)

### Cross-Sprint Dependencies
- **Blocks**: None (standalone feature)
- **Blocked By**: Ideally have MessageContent, ToolUse, ToolResult components first, but can implement simplified versions if needed
- **Nice to Have**: Code highlighting, image rendering for complete message display

---

## Risks

### Technical Risks

**Risk 1**: Conversation API format mismatch between old and new
- **Likelihood**: High (STATUS notes different structure)
- **Impact**: High (blocks entire feature)
- **Mitigation**: Prioritize data model alignment task first, validate with backend team

**Risk 2**: Performance with very long conversations (500+ messages)
- **Likelihood**: Medium
- **Impact**: Medium (UI sluggish, poor UX)
- **Mitigation**: Use virtualization for message list, lazy render tool call details, paginate if needed

**Risk 3**: Complex message flow diagram layout
- **Likelihood**: Medium
- **Impact**: Low (can simplify or remove)
- **Mitigation**: Use established graph library, fall back to simple tree view if complex layout fails

### Data Risks

**Risk 4**: Missing or incomplete conversation data from backend
- **Likelihood**: Medium
- **Impact**: Medium (partial features work, some broken)
- **Mitigation**: Define clear data contract, add fallback UI for missing fields, validate with real data early

**Risk 5**: Sidechain (subagent) conversation structure complexity
- **Likelihood**: High (sidechains are complex)
- **Impact**: Medium (confusing UI)
- **Mitigation**: Start with simple linear conversations, iterate on sidechain visualization

---

## Testing Strategy

### Unit Tests
- Conversation data model adapter (old → new format)
- Message thread rendering with various message types
- Tool call/result component rendering
- Metadata calculations (duration, counts)
- Expand/collapse state management

### Integration Tests
- Load conversation from API → display full thread
- Click conversation in list → thread view opens
- Tool calls render correctly with real data
- Message flow diagram builds from conversation structure

### E2E Tests
- Full user flow: Navigate to conversations → select conversation → view thread → expand tool call → collapse message
- Long conversation (50+ messages) loads and scrolls smoothly
- Conversation with branches displays correctly in flow diagram

### Manual Testing Scenarios
1. Simple conversation (5 user/assistant turns, no tools)
2. Conversation with multiple tool calls (Read, Write, Bash)
3. Conversation with subagent (sidechain branching)
4. Very long conversation (100+ messages)
5. Conversation with errors (failed tool calls, partial responses)

---

## Recommended Sprint Approach

**Week 1**:
1. Day 1: Conversation data model alignment + validation
2. Day 2-3: Message thread display component (basic)
3. Day 4: Conversation list view
4. Day 5: Testing and integration

**Week 2**:
1. Day 1-3: Tool call visualization inline (complex)
2. Day 4: Conversation metadata panel
3. Day 5: Message flow diagram (MVP version)

**Total Effort**: 8-10 days

---

## Success Metrics

- Users can view full conversation thread in under 5 seconds
- Tool calls render correctly for all Claude Code tool types
- Conversations with 100+ messages load without performance issues
- Message flow diagram correctly represents branching for 95% of conversations
- Zero data model mismatch errors in production

---

## Open Questions

1. **API Format**: What is the exact structure of `/api/conversations` in new backend?
   - **Action**: Document current API response, compare with old format, create migration plan

2. **Sidechain Display**: How should subagent (sidechain) conversations be displayed?
   - **Options**: (A) Inline with visual indent, (B) Separate expandable section, (C) Only in flow diagram
   - **Recommendation**: Start with (A) inline with indent, iterate based on feedback

3. **Real-Time Updates**: Should conversations update in real-time as Claude Code session progresses?
   - **Decision**: Out of scope for this sprint, add polling or WebSocket in future

4. **Conversation Filtering**: Do users need to filter conversations by project, date, or model?
   - **Decision**: Out of scope for MVP, add to backlog

5. **Message Flow Library**: Which graph library to use? Custom implementation?
   - **Recommendation**: Try `react-flow` first, fall back to simple tree if too complex

---

## Related Epics

- **Epic**: brandon-fryslie_claude-code-proxy-jaq (Conversation Threads)
- **Phase**: 5 (Advanced Features)
- **Depends On**: Phase 1-4 (message rendering, tool display)
- **Enables**: Deeper debugging, understanding agent decision-making, session analysis

---

## Notes

- Conversation context is critical for understanding individual requests
- Claude Code logs are rich but complex (sidechains, tool calls, parent relationships)
- Old dashboard's ConversationThread is 202 LOC but MessageFlow adds 281 LOC (total ~500 LOC to port)
- Consider starting with simplified conversation view, iterate to full complexity
- Integration with request detail view: Link from conversation message to corresponding request in request list
