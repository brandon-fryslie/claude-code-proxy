# Status Report - 2025-12-27 23:30:00
Scope: feature/conversation-search-indexing
Confidence: FRESH

## Executive Summary
**Overall:** 0% complete | **Critical issues:** 5 | **Tests reliable:** N/A (not started)

**Decision Made:** SQLite FTS5 for full-text search (research completed 2025-12-27)

**Current State:** Frontend conversation browser COMPLETE with client-side filtering. Backend indexing and search NOT STARTED.

## Evaluation Reuse Summary
- Carried forward: 1 FRESH finding (work-evaluator conversation-browser assessment)
- Fresh evaluation: Backend search infrastructure analysis

## Context

### Research Decision (from ROADMAP.md)
- **Technology:** SQLite FTS5 for full-text search
- **Rationale:** Embedded in existing SQLite, no separate service, fast queries
- **Tradeoffs:** No fuzzy search, manual snippet extraction
- **Requirements:**
  1. Full-text search across message content, tool calls, metadata
  2. Fast queries even with thousands of conversations
  3. Lightweight - embedded in existing SQLite
  4. Incremental indexing as new conversations come in

### What Exists (VERIFIED)

#### 1. Conversation Loading (COMPLETE)
**File:** `proxy/internal/service/conversation.go`
- ✅ `ConversationService` interface with 3 methods
- ✅ `GetConversations()` - walks `~/.claude/projects/`, parses JSONL files
- ✅ `GetConversation(projectPath, sessionID)` - loads single conversation
- ✅ `GetConversationsByProject(projectPath)` - project-specific listing
- ✅ JSONL parsing with 10MB buffer for large messages
- ✅ Error handling for malformed lines (skip and continue)
- ✅ Timestamp parsing with RFC3339/RFC3339Nano fallback
- ✅ Sorting by file modification time (newest first)

**Data Structures:**
```go
type Conversation struct {
    SessionID    string
    ProjectPath  string
    ProjectName  string
    Messages     []*ConversationMessage
    StartTime    time.Time
    EndTime      time.Time
    MessageCount int
    FileModTime  time.Time
}

type ConversationMessage struct {
    ParentUUID  *string
    IsSidechain bool
    UserType    string
    CWD         string
    SessionID   string
    Version     string
    Type        string
    Message     json.RawMessage  // ⚠️ Raw JSON, needs parsing for indexing
    UUID        string
    Timestamp   string
    ParsedTime  time.Time
}
```

#### 2. SQLite Storage (READY for extension)
**File:** `proxy/internal/service/storage_sqlite.go`
- ✅ Existing `requests` table with FTS support available
- ✅ Migration system in `runMigrations()` for adding columns
- ✅ SQLite connection with WAL mode, busy_timeout, and optimizations
- ✅ **FTS5 VERIFIED:** `PRAGMA compile_options` shows `ENABLE_FTS5`
- ✅ go-sqlite3 v1.14.28 (latest, supports FTS5)

#### 3. API Endpoints (COMPLETE for read-only)
**File:** `proxy/internal/handler/handlers.go`
- ✅ `GetConversations(w, r)` - handler exists (line 871)
- ✅ `GetConversation(projectPath, sessionID)` - handler exists (line 961)
- ✅ `GetConversationsByProject(projectPath)` - handler exists (line 971)
- ⚠️ **NO SEARCH ENDPOINT** - needs `/api/conversations/search?q=...`

#### 4. Frontend Conversation Browser (COMPLETE)
**Status:** From WORK-EVALUATION-conversation-browser-20251227_035038.md
- ✅ Search bar with real-time filtering (client-side only)
- ✅ List view with compact items, keyboard navigation, sorting
- ✅ Thread view with collapsible tools and search
- ✅ Empty/loading states, dark mode, performance optimizations
- ✅ **Limitations:** Client-side filtering only - loads ALL conversations then filters
- ⚠️ **Scalability Issue:** Works for <100 conversations, will be slow for 1000+

**Frontend Search Implementation** (client-side):
- `filterConversations()` - searches project name, message content, tool names
- `matchesSearchQuery()` - case-insensitive, multi-term OR logic
- `highlightMatches()` - React components with `<mark>` tags
- `extractTextFromContent()` - parses message JSON
- `extractToolNames()` - finds tool_use blocks

### What's Missing (CRITICAL GAPS)

#### 1. Database Schema - Conversations Tables
**Priority:** HIGH
**Impact:** Blocks all search functionality

**Required Tables:**
```sql
-- Main conversations table
CREATE TABLE conversations (
    id TEXT PRIMARY KEY,              -- sessionId
    project_path TEXT NOT NULL,
    project_name TEXT NOT NULL,
    start_time DATETIME,
    end_time DATETIME,
    message_count INTEGER,
    file_path TEXT NOT NULL,          -- Full path to JSONL file
    file_mtime DATETIME,              -- For staleness detection
    indexed_at DATETIME,              -- When last indexed
    UNIQUE(file_path)
);

CREATE INDEX idx_conversations_project ON conversations(project_path);
CREATE INDEX idx_conversations_mtime ON conversations(file_mtime DESC);

-- FTS5 virtual table for full-text search
CREATE VIRTUAL TABLE conversations_fts USING fts5(
    conversation_id,                  -- FK to conversations.id
    message_uuid,                     -- UUID of specific message
    message_type,                     -- 'user', 'assistant', 'system'
    content_text,                     -- Extracted text content
    tool_names,                       -- Space-separated tool names
    timestamp,                        -- Message timestamp
    tokenize='porter unicode61'      -- Better tokenization
);
```

**Why This Schema:**
- Separate `conversations` table for metadata (fast filtering by date, project)
- FTS5 virtual table for content search (optimized for text queries)
- `file_mtime` for detecting JSONL changes (incremental indexing)
- `indexed_at` for tracking staleness
- Porter stemming for better search (e.g., "implement" matches "implementation")

#### 2. JSONL Content Extraction
**Priority:** HIGH
**Impact:** Cannot populate FTS index without this

**Missing Component:** Content parser for `Message json.RawMessage`

The current `ConversationMessage.Message` field is `json.RawMessage` - needs parsing to extract:
1. Text content from user/assistant messages
2. Tool names from `tool_use` blocks
3. Tool input/output from tool interactions
4. System prompts

**Challenge:** Message format varies by `Type` field:
- `"userMessage"` - likely contains text content
- `"assistantMessage"` - may contain text + tool_use blocks
- `"toolResult"` - contains tool output
- Other types? (needs investigation of real JSONL files)

**Risk:** HIGH - message format is undocumented, needs reverse engineering from actual files.

#### 3. File Watcher Service
**Priority:** MEDIUM
**Impact:** Manual re-indexing required without this

**Missing:** `fsnotify`-based watcher for `~/.claude/projects/`

**Required Functionality:**
```go
type ConversationIndexer struct {
    storage     *SQLiteStorage
    watcher     *fsnotify.Watcher
    indexQueue  chan string  // File paths to index
}

// Watch ~/.claude/projects/ for:
// - CREATE events (new JSONL files)
// - WRITE events (existing files modified)
// - DELETE events (remove from index)

// Debounce writes (JSONL files written incrementally during conversation)
```

**Dependency:** `github.com/fsnotify/fsnotify` (not in go.mod)

**Complexity:** MEDIUM
- Handle rapid write events (debouncing)
- Graceful shutdown (close watcher)
- Error recovery (watcher can fail, need restart logic)

#### 4. Search API Endpoint
**Priority:** HIGH
**Impact:** Frontend cannot use backend search without this

**Missing:** `GET /api/conversations/search?q=<query>`

**Required Response:**
```json
{
  "query": "authentication bug",
  "results": [
    {
      "conversationId": "agent-abc123",
      "projectName": "auth-service",
      "matchCount": 3,
      "messages": [
        {
          "uuid": "msg-456",
          "timestamp": "2025-12-27T10:30:00Z",
          "type": "user",
          "snippet": "...found an <mark>authentication</mark> <mark>bug</mark> in..."
        }
      ]
    }
  ],
  "totalResults": 15
}
```

**Requirements:**
- Pagination (limit/offset)
- Snippet extraction with context (±50 chars)
- Highlighting markup (`<mark>` tags)
- Sort by relevance (FTS5 BM25 ranking)
- Optional filters: project, date range

#### 5. Indexing Orchestration
**Priority:** HIGH
**Impact:** Index never gets built without this

**Missing Components:**

1. **Initial Indexing** (startup or on-demand)
   - Walk all existing JSONL files
   - Parse and index all conversations
   - Track progress (could take minutes for 1000+ conversations)
   - Idempotent (safe to re-run)

2. **Incremental Indexing** (file watcher triggers)
   - Debounce rapid writes (conversation in progress)
   - Parse only changed files
   - Update existing index entries
   - Handle deletions

3. **Staleness Detection**
   - Compare `file_mtime` vs `indexed_at`
   - Re-index if file changed
   - Background task? Or on-demand?

**Performance Considerations:**
- Parsing 1000 conversations with 50 messages each = 50,000 messages
- FTS5 insert performance: ~10,000 rows/sec (should be <10 seconds)
- JSONL parsing: depends on message size, likely bottleneck

### What Needs Changes

#### 1. Storage Interface Extension
**File:** `proxy/internal/service/storage.go`
**Change:** Add conversation search methods to interface

```go
type StorageService interface {
    // ... existing methods ...

    // Conversation indexing
    IndexConversation(conv *Conversation) error
    RemoveConversation(conversationID string) error
    SearchConversations(query string, opts SearchOptions) (*SearchResults, error)
    GetIndexStatus() (*IndexStatus, error)
}

type SearchOptions struct {
    Query       string
    ProjectPath string  // Optional filter
    StartTime   *time.Time
    EndTime     *time.Time
    Limit       int
    Offset      int
}

type SearchResults struct {
    Query        string
    Results      []*ConversationMatch
    TotalResults int
}

type ConversationMatch struct {
    ConversationID string
    ProjectName    string
    MatchCount     int
    Messages       []*MessageSnippet
}

type MessageSnippet struct {
    UUID      string
    Timestamp time.Time
    Type      string
    Snippet   string  // With <mark> tags
}

type IndexStatus struct {
    TotalConversations int
    TotalMessages      int
    LastIndexed        *time.Time
    IsIndexing         bool
}
```

#### 2. Handler Extension
**File:** `proxy/internal/handler/handlers.go`
**Change:** Add search handler

```go
func (h *Handler) SearchConversations(w http.ResponseWriter, r *http.Request) {
    query := r.URL.Query().Get("q")
    if query == "" {
        writeErrorResponse(w, "Query parameter 'q' required", http.StatusBadRequest)
        return
    }

    // Parse optional filters
    opts := service.SearchOptions{
        Query:  query,
        Limit:  50,
        Offset: 0,
    }

    // ... parse other params ...

    results, err := h.storageService.SearchConversations(query, opts)
    // ... handle error, write response ...
}
```

#### 3. Router Configuration
**File:** `proxy/cmd/proxy/main.go`
**Change:** Add search route

```go
router.HandleFunc("/api/conversations/search", handler.SearchConversations).Methods("GET")
```

#### 4. Frontend API Client
**File:** `web/app/routes/api.conversations.tsx`
**Change:** Add search route (separate from list)

```typescript
// New file: web/app/routes/api.conversations.search.tsx
export const loader: LoaderFunction = async ({ request }) => {
  const url = new URL(request.url);
  const query = url.searchParams.get("q");

  const backendUrl = new URL('http://localhost:3001/api/conversations/search');
  backendUrl.searchParams.append('q', query);
  // ... add other filters ...

  const response = await fetch(backendUrl.toString());
  return json(await response.json());
};
```

#### 5. Frontend Search Toggle
**File:** `web/app/components/ConversationSearch.tsx`
**Change:** Add toggle between client-side and server-side search

**Why:** Gradual migration - keep client-side search working, add server-side as enhancement.

```typescript
const useBackendSearch = query.length >= 3; // Use backend for 3+ chars

if (useBackendSearch) {
  // Fetch from /api/conversations/search
} else {
  // Use existing filterConversations()
}
```

### Dependencies and Risks

#### Dependencies
1. **Go Dependencies:**
   - ✅ `github.com/mattn/go-sqlite3` v1.14.28 - already present, FTS5 verified
   - ❌ `github.com/fsnotify/fsnotify` - MISSING, need to add for file watching
   - Optional: `golang.org/x/sync/errgroup` for concurrent indexing

2. **Database Migration:**
   - ✅ Migration system exists in `storage_sqlite.go`
   - Need new migration for conversations tables

3. **Frontend:**
   - ✅ No new dependencies needed
   - ✅ React Query already handles caching

#### Risks

| Risk | Severity | Mitigation |
|------|----------|------------|
| **Message format undocumented** | HIGH | Reverse engineer from real JSONL files, write parser tests |
| **JSONL parsing performance** | MEDIUM | Benchmark with large files, consider streaming parser |
| **File watcher failures** | MEDIUM | Add health check, auto-restart logic |
| **FTS5 query syntax exposure** | LOW | Sanitize user input, use parameterized queries |
| **Index staleness** | LOW | Add UI indicator, background re-index task |
| **Migration breaking changes** | LOW | Test migrations on copy of production DB first |

#### Ambiguities

| Area | Question | What Was Assumed | Should Ask |
|------|----------|------------------|------------|
| **Indexing trigger** | When to build initial index? | On startup | Startup auto-index? Or manual trigger in UI? Large datasets may delay startup |
| **Snippet length** | How much context? | ±50 chars | What's the right balance? More context = larger response, better UX |
| **Search scope** | Search tool inputs/outputs? | Yes, index everything | Tool results can be huge (code diffs). Index them? |
| **Pagination** | Default page size? | 50 results | What's reasonable? 20? 50? 100? |
| **Relevance ranking** | Use BM25 scoring? | Yes, FTS5 default | Good enough? Or need custom ranking (boost recent conversations)? |
| **Debounce delay** | How long to wait after file write? | 2 seconds | Conversations can run for minutes. 2s? 5s? 10s? |

### Runtime Check Results
| Check | Status | Output Summary |
|-------|--------|----------------|
| SQLite FTS5 support | ✅ PASS | `PRAGMA compile_options` shows `ENABLE_FTS5` |
| go-sqlite3 version | ✅ PASS | v1.14.28 (supports FTS5) |
| Conversation JSONL files | ✅ PASS | Found files in `~/.claude/projects/` |
| Existing tests | ✅ PASS | `go test ./...` passes (handlers, storage, router) |
| Frontend conversation browser | ✅ PASS | From WORK-EVALUATION: 12/13 criteria met |
| Backend search endpoint | ❌ NOT FOUND | `/api/conversations/search` does not exist |
| Conversations table | ❌ NOT FOUND | `SELECT * FROM conversations` - no such table |
| File watcher | ❌ NOT FOUND | No fsnotify in go.mod |

### Missing Checks (implementer should create)

1. **JSONL Message Format Test** (`proxy/internal/service/conversation_test.go`)
   - Load real JSONL file from `~/.claude/projects/`
   - Parse all message types (userMessage, assistantMessage, toolResult, etc.)
   - Verify content extraction works for each type
   - Document message format variants
   - Test with edge cases: empty messages, huge tool outputs, Unicode

2. **FTS5 Search Query Test** (`proxy/internal/service/storage_sqlite_test.go`)
   - Create test conversations with known content
   - Index them in FTS5 table
   - Run various search queries (single term, multi-term, phrases)
   - Verify result ranking (BM25)
   - Test special characters, quotes, operators
   - Verify snippet extraction accuracy

3. **Incremental Indexing Test** (`proxy/internal/service/indexer_test.go`)
   - Create JSONL file, index it
   - Modify file (append message)
   - Trigger re-indexing
   - Verify new content searchable
   - Verify old content still present
   - Test deletion scenario

4. **File Watcher Integration Test** (`proxy/internal/service/indexer_integration_test.go`)
   - Start file watcher on test directory
   - Create new JSONL file
   - Verify indexing triggered
   - Modify existing file
   - Verify re-indexing triggered
   - Test debouncing (rapid writes)
   - Should run in <10 seconds

5. **Search API E2E Test** (`proxy/internal/handler/handlers_test.go`)
   - Seed database with indexed conversations
   - HTTP GET `/api/conversations/search?q=test`
   - Verify response format
   - Test pagination (limit/offset)
   - Test filters (project, date range)
   - Verify snippets have highlighting

## Data Flow Verification
| Flow | Input | Process | Store | Retrieve | Display |
|------|-------|---------|-------|----------|---------|
| **Load conversations** | JSONL files | ✅ Parse | ❌ Not indexed | ✅ GetConversations | ✅ Frontend list |
| **Search conversations** | User query | ❌ No search | ❌ No FTS index | ❌ No endpoint | ⚠️ Client-side only |
| **Index new conversation** | File watch event | ❌ No watcher | ❌ No indexing | - | - |
| **Update index** | JSONL modified | ❌ No detection | ❌ No re-index | - | - |

## Implementation Assessment
| Component | Status | Confidence | Evidence | Issues |
|-----------|--------|------------|----------|--------|
| Conversation loading | COMPLETE | FRESH | conversation.go:59-112 | None |
| SQLite FTS5 support | READY | FRESH | PRAGMA shows ENABLE_FTS5 | None |
| API endpoints (read) | COMPLETE | FRESH | handlers.go:871,961,971 | No search endpoint |
| Frontend browser | COMPLETE | RECENT | WORK-EVALUATION (92% complete) | Client-side only |
| Database schema | NOT STARTED | FRESH | No conversations tables | Design needed |
| JSONL content parser | NOT STARTED | RISKY | Message format unknown | High risk |
| File watcher | NOT STARTED | FRESH | fsnotify not installed | Medium complexity |
| Search API | NOT STARTED | FRESH | No handler exists | Needs interface design |
| Indexing service | NOT STARTED | FRESH | No orchestration code | High complexity |

## Recommendations

### Must Fix (for implementation to start)

1. **Reverse engineer JSONL message format** (2-4 hours)
   - Load 10+ real JSONL files from `~/.claude/projects/`
   - Document all message types and their structures
   - Create test fixtures
   - **CRITICAL:** Cannot index without knowing format

2. **Design conversations database schema** (1 hour)
   - Review provided schema above
   - Decide on indexing strategy (all content? tool results?)
   - Plan migration script
   - **CRITICAL:** Foundation for all search work

3. **Clarify ambiguities** (30 min)
   - When to trigger initial indexing (startup vs manual)
   - Debounce delay for file writes
   - Search scope (include tool results?)
   - Snippet length and pagination defaults
   - **RECOMMENDED:** Avoid arbitrary decisions that may need rework

### Implementation Sequence (suggested)

**Phase 1: Core Infrastructure** (8-12 hours)
1. Add fsnotify dependency to go.mod
2. Create conversations + FTS5 tables (with migration)
3. Write JSONL message parser (with comprehensive tests)
4. Implement `IndexConversation()` in storage layer

**Phase 2: Indexing Service** (6-8 hours)
5. Create ConversationIndexer service
6. Implement file watcher with debouncing
7. Add initial indexing (walk all JSONL files)
8. Add health check and index status endpoint

**Phase 3: Search API** (4-6 hours)
9. Implement SearchConversations in storage
10. Write snippet extraction with highlighting
11. Add search handler with pagination
12. Wire up route in main.go

**Phase 4: Frontend Integration** (2-4 hours)
13. Add search API route in Remix
14. Toggle between client/server search (3+ chars)
15. Display search results with snippets
16. Add loading/error states

**Phase 5: Polish** (4-6 hours)
17. Add comprehensive tests (5 test suites above)
18. Performance benchmarks (1000+ conversations)
19. Error handling and logging
20. Documentation and README

**Total Estimate:** 24-36 hours (assuming no major surprises)

### Should Consider

4. **Background re-indexing task** - Detect stale indexes, rebuild automatically
5. **Search result caching** - LRU cache for common queries
6. **Partial indexing** - Index only last 1000 conversations for speed
7. **Search analytics** - Track popular queries, improve ranking

### Nice to Have

8. **Fuzzy search** - Use trigram similarity for typo tolerance (SQLite doesn't support, needs external lib)
9. **Advanced search syntax** - Support operators like `tool:bash`, `project:auth-service`
10. **Search history** - Remember recent searches per user
11. **Export search results** - Download as JSON/CSV

## Verdict

### Issues Severity
- **HIGH:** 5 (JSONL parser, DB schema, indexer, search API, file watcher)
- **MEDIUM:** 3 (ambiguities around indexing triggers, scope, performance)
- **LOW:** 2 (pagination defaults, snippet length)

### Completion Status
- **Infrastructure:** 40% (SQLite ready, conversation loading works)
- **Implementation:** 0% (no search code exists)
- **Frontend:** 100% (client-side search works, ready for server-side)
- **Testing:** 0% (no search tests)

**Overall: 0% of backend search complete** (frontend at 100% for client-side)

## Workflow Recommendation

**❌ CANNOT CONTINUE** - Too many critical unknowns

**Blocking Issues:**
1. JSONL message format undocumented (HIGH RISK)
2. Ambiguities need clarification (startup indexing, debounce, scope)
3. No design consensus on search API response format

**Recommended Next Steps:**

### Option A: Research-First Approach (RECOMMENDED)
1. Create `/do:research` task for JSONL message format
2. Load 20+ real files, document all message types
3. Create test fixtures and parser
4. Return to planning with concrete format knowledge
5. **Effort:** 4-6 hours research, reduces implementation risk

### Option B: Iterative Approach
1. Answer ambiguity questions (see Pausing for Clarification below)
2. Start with minimal schema (conversations + basic FTS)
3. Implement parser for common message types only
4. Add more types as discovered
5. **Effort:** Faster start, but may need rework

### Option C: Feature Flag Approach
1. Implement full backend search behind feature flag
2. Keep client-side search as default
3. Gradual rollout as confidence grows
4. **Effort:** More code, but safer migration

## Pausing for Clarification

### Question 1: Initial Indexing Trigger
**Context:** Building FTS index requires parsing all JSONL files. For 1000 conversations with 50 messages each, this could take 30-60 seconds.

**How it might be guessed:** "Index on startup" (delays startup) or "Manual button in UI" (requires user action)

**Options:**
- **Option A:** Background indexing on first startup, show progress indicator
  - Tradeoff: Complex state management, but transparent UX
- **Option B:** Manual "Build Index" button in conversations UI
  - Tradeoff: Simple, but users must remember to click
- **Option C:** Lazy indexing - build as users access conversations
  - Tradeoff: Gradual, but inconsistent search results initially

**Impact of wrong choice:** Option A could annoy users with slow startup. Option B could confuse users why search doesn't work. Option C adds complexity.

### Question 2: Search Scope - Tool Results
**Context:** Tool results can contain massive text (entire file diffs, large JSON responses). Indexing them bloats the FTS table and slows search.

**How it might be guessed:** "Index everything" (bloated) or "Skip tool results" (miss important context)

**Options:**
- **Option A:** Index all content including tool results
  - Tradeoff: Complete search, but 10x larger index, slower queries
- **Option B:** Index tool names and inputs only, skip results
  - Tradeoff: Faster, smaller, but miss output content
- **Option C:** Index first 500 chars of tool results
  - Tradeoff: Balanced, but arbitrary truncation

**Impact of wrong choice:** Option A could make search unusably slow. Option B might miss valuable context. Option C requires snippet tuning.

### Question 3: File Watch Debounce Delay
**Context:** JSONL files are written continuously during a conversation. Each write triggers a file event. Too short debounce = re-index every 0.5s. Too long = delayed search results.

**How it might be guessed:** "2 seconds should be enough" (common default, but is it right here?)

**Options:**
- **Option A:** 2 seconds - common debounce default
  - Tradeoff: May re-index too frequently during active conversation
- **Option B:** 10 seconds - longer delay
  - Tradeoff: Less re-indexing, but 10s lag before search finds new messages
- **Option C:** Adaptive - 2s normally, 30s during detected conversation activity
  - Tradeoff: Optimal, but complex to implement

**Impact of wrong choice:** Too short = CPU thrashing during conversations. Too long = confusing lag in search results.

### Question 4: Pagination and Result Limits
**Context:** Search could match thousands of messages across hundreds of conversations. How much to return?

**How it might be guessed:** "50 results per page" (common default)

**Options:**
- **Option A:** 20 results per page (more pages, faster response)
- **Option B:** 50 results per page (fewer pages, medium response)
- **Option C:** 100 results per page (fewer pages, slower response)
- **Option D:** Configurable per-user preference

**Impact of wrong choice:** Too few = annoying pagination. Too many = slow response, poor UX on mobile.

---

**RECOMMENDATION:** Answer questions 1-3 before starting implementation. Question 4 can be decided during implementation (easy to change).

