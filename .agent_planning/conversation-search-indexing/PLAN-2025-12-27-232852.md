# Implementation Plan: Conversation Search Indexing
Generated: 2025-12-27 23:28:52
Source: STATUS-20251227_233000.md
Scope: Backend full-text search infrastructure for conversations

## Executive Summary

**Current State:** Frontend conversation browser is 100% complete with client-side search. Backend has conversation loading and SQLite infrastructure ready, but NO search indexing or API exists (0% complete).

**Technology Decision:** SQLite FTS5 (research completed, embedded in existing DB, no new dependencies except fsnotify)

**Sprint Goal:** Deliver searchable conversation index with working API endpoint. Enable frontend to switch from client-side to server-side search for scalability.

**Total Work Items:** 3 (P0, P1, P2)
**Estimated Complexity:** HIGH (24-36 hours) - requires format research, schema design, indexing orchestration

**Key Risks:**
- JSONL message format undocumented (HIGH) - needs reverse engineering
- Performance unknown for 1000+ conversations (MEDIUM)
- File watcher reliability (MEDIUM)

---

## Sprint Scope

### Deliverables (In Scope)
1. **SQLite Schema** - conversations + FTS5 tables with migration
2. **Indexing Service** - Parse JSONL, populate FTS, handle incremental updates
3. **Search API** - `/api/conversations/search` endpoint with pagination

### Deferred (Future Sprints)
- Search result highlighting/snippets (manual extraction too complex for MVP)
- Advanced filters (date range, project-specific)
- Real-time indexing with WebSocket updates
- Search UI enhancements beyond toggle

### Decisions Made (User Confirmed)
1. **Indexing trigger:** Auto-index on startup (user accepts initial delay)
2. **Search scope:** Index message text + tool names (NOT full tool results - too large)
3. **Debounce delay:** 5 seconds for file watcher
4. **Pagination:** 50 results per page

---

## Work Items

## [P0] Database Schema & JSONL Message Parser

**Status**: Not Started
**Effort**: Large (8-12 hours)
**Dependencies**: None (blocks all other work)
**Spec Reference**: ROADMAP.md Phase 1 • **Status Reference**: STATUS-20251227_233000.md §What's Missing (CRITICAL GAPS) #1, #2

### Description
Create the foundation for conversation search: SQLite tables for metadata and FTS5 index, plus a robust parser for extracting searchable content from JSONL message files.

**Why This is P0:**
- Blocks all downstream work (can't index without schema, can't search without parser)
- JSONL format is undocumented - reverse engineering is HIGH RISK
- Schema design affects performance for all future queries

**What Exists (verified):**
- ✅ SQLite connection with FTS5 support enabled
- ✅ Migration system in `storage_sqlite.go`
- ✅ Basic conversation loading in `conversation.go`
- ✅ `ConversationMessage` struct with `Message json.RawMessage` field

**What's Missing:**
- Database tables: `conversations` (metadata) + `conversations_fts` (full-text index)
- Message parser: Extract text content from `json.RawMessage` by type
- Content extractor: Parse tool_use blocks, tool results, system prompts
- Migration script: Create tables, indexes, FTS5 configuration

### Acceptance Criteria

- [ ] **Schema Created**: `conversations` table stores sessionID, project info, timestamps, file path, indexed_at
- [ ] **FTS5 Table Ready**: `conversations_fts` virtual table with porter stemming, indexes message content + tool names
- [ ] **Migration Successful**: Running `go run cmd/proxy/main.go` creates tables on first start, no errors
- [ ] **JSONL Parser Works**: Can extract text content from all message types (userMessage, assistantMessage, toolResult, etc.)
- [ ] **Parser Tested**: Unit tests cover 5+ real JSONL files from `~/.claude/projects/`, handle edge cases (empty messages, large tool outputs, Unicode)
- [ ] **Tool Name Extraction**: Parser identifies and extracts tool names from tool_use blocks (e.g., "bash", "read_file")
- [ ] **Format Documented**: Code comments or doc string explain message format variants discovered

### Technical Notes

**Schema Design:**
```sql
-- Metadata table (fast filtering by project, date)
CREATE TABLE conversations (
    id TEXT PRIMARY KEY,              -- sessionID
    project_path TEXT NOT NULL,
    project_name TEXT NOT NULL,
    start_time DATETIME,
    end_time DATETIME,
    message_count INTEGER,
    file_path TEXT NOT NULL UNIQUE,   -- For staleness detection
    file_mtime DATETIME,              -- Detect JSONL changes
    indexed_at DATETIME,              -- Last indexed timestamp
    UNIQUE(file_path)
);

CREATE INDEX idx_conversations_project ON conversations(project_path);
CREATE INDEX idx_conversations_mtime ON conversations(file_mtime DESC);

-- FTS5 virtual table (optimized text search)
CREATE VIRTUAL TABLE conversations_fts USING fts5(
    conversation_id UNINDEXED,        -- FK to conversations.id
    message_uuid UNINDEXED,           -- UUID of specific message
    message_type,                     -- 'user', 'assistant', 'system'
    content_text,                     -- Extracted text content
    tool_names,                       -- Space-separated tool names
    timestamp UNINDEXED,              -- Message timestamp
    tokenize='porter unicode61'      -- Better stemming for search
);
```

**Message Parser Approach:**
1. Load 10-20 real JSONL files from `~/.claude/projects/`
2. Examine `Message` field structure for each `Type` variant
3. Create type-specific extractors:
   - `userMessage` → extract text content
   - `assistantMessage` → extract text + tool_use blocks
   - `toolResult` → extract result content (truncate if >500 chars?)
   - Other types → document and handle gracefully
4. Unit test with fixtures from real files

**Parser Location:**
- Add to `proxy/internal/service/conversation.go` as `ExtractMessageContent(msg *ConversationMessage) (text string, toolNames []string, error)`
- Keep parsing logic separate from indexing logic (easier to test)

**Migration Pattern:**
- Follow existing pattern in `runMigrations()` in `storage_sqlite.go`
- Check `PRAGMA user_version` to track schema version
- Increment version after successful migration
- Make migration idempotent (safe to re-run)

**Risks:**
- Message format may have unexpected variants (plan for graceful failures)
- Large tool results (file diffs) could bloat FTS index → truncate to 500 chars
- Unicode handling in FTS5 tokenizer → test with emoji, non-ASCII

**Files to Modify:**
- `proxy/internal/service/storage_sqlite.go` - add migration, schema creation
- `proxy/internal/service/conversation.go` - add parser functions
- `proxy/internal/service/conversation_test.go` - add parser tests with real fixtures

---

## [P1] Conversation Indexing Service with File Watcher

**Status**: Not Started
**Effort**: Large (10-14 hours)
**Dependencies**: P0 (schema + parser must exist)
**Spec Reference**: ROADMAP.md Phase 1 conversation-search-indexing • **Status Reference**: STATUS-20251227_233000.md §What's Missing (CRITICAL GAPS) #3, #5

### Description
Build the service that keeps the FTS index synchronized with JSONL files. Includes initial indexing on startup, file watcher for incremental updates, and debouncing logic to avoid re-indexing during active conversations.

**Why This is P1:**
- Index needs to be populated before search works
- File watcher enables "always up-to-date" search without manual triggers
- Debouncing critical for performance (avoid re-indexing every 0.5s during conversation)

**What Exists:**
- ✅ Conversation loading from JSONL in `conversation.go`
- ✅ Storage interface pattern in `storage.go`

**What's Missing:**
- `ConversationIndexer` service orchestrating indexing lifecycle
- fsnotify-based file watcher for `~/.claude/projects/`
- Debouncing logic (5 second delay after last write)
- Initial indexing walk (on startup or on-demand)
- Staleness detection (compare `file_mtime` vs `indexed_at`)

### Acceptance Criteria

- [ ] **Initial Indexing Works**: On startup, service walks `~/.claude/projects/`, indexes all JSONL files, populates both tables
- [ ] **Incremental Updates**: File watcher detects new/modified JSONL files, triggers re-indexing
- [ ] **Debouncing Active**: Writing to JSONL file rapidly (simulated) only triggers one re-index after 5 seconds of inactivity
- [ ] **Staleness Handling**: Modified JSONL files (changed mtime) are detected and re-indexed on next startup
- [ ] **Graceful Shutdown**: Service cleanly stops file watcher, closes channels, no goroutine leaks
- [ ] **Error Recovery**: File watcher failures (e.g., too many open files) log error, attempt restart after 10 seconds
- [ ] **Dependency Added**: `github.com/fsnotify/fsnotify` added to `go.mod`

### Technical Notes

**Service Structure:**
```go
type ConversationIndexer struct {
    storage       *SQLiteStorage
    watcher       *fsnotify.Watcher
    indexQueue    chan string           // File paths to index
    debounceTimer map[string]*time.Timer // Per-file debounce
    mu            sync.Mutex             // Protect debounceTimer map
    done          chan struct{}          // Shutdown signal
}

func NewConversationIndexer(storage *SQLiteStorage) (*ConversationIndexer, error)
func (ci *ConversationIndexer) Start() error    // Start watcher, begin initial index
func (ci *ConversationIndexer) Stop()           // Clean shutdown
func (ci *ConversationIndexer) IndexFile(path string) error  // Index single JSONL file
```

**Initial Indexing Flow:**
1. On `Start()`, walk `~/.claude/projects/` recursively
2. Find all `.jsonl` files
3. For each file:
   - Check if already indexed (query `conversations` by `file_path`)
   - Compare `file_mtime` vs `indexed_at`
   - If stale or missing, parse and index
4. Log progress (e.g., "Indexed 245/1000 conversations")

**File Watcher Flow:**
1. Create fsnotify watcher on `~/.claude/projects/`
2. Watch for CREATE, WRITE, REMOVE events
3. On WRITE/CREATE:
   - Cancel existing debounce timer for this file (if any)
   - Start new 5-second timer
   - When timer fires → send file path to indexQueue
4. On REMOVE:
   - Delete from `conversations` and `conversations_fts` tables
5. Background goroutine processes indexQueue:
   - Parse JSONL file
   - Upsert to `conversations` table
   - Delete old FTS entries for this conversation
   - Insert new FTS entries for all messages

**Debouncing Implementation:**
```go
func (ci *ConversationIndexer) handleFileEvent(path string) {
    ci.mu.Lock()
    defer ci.mu.Unlock()

    // Cancel existing timer
    if timer, exists := ci.debounceTimer[path]; exists {
        timer.Stop()
    }

    // Start new 5-second timer
    ci.debounceTimer[path] = time.AfterFunc(5*time.Second, func() {
        ci.indexQueue <- path
        ci.mu.Lock()
        delete(ci.debounceTimer, path)
        ci.mu.Unlock()
    })
}
```

**Performance Considerations:**
- Initial indexing of 1000 conversations × 50 messages = 50,000 FTS inserts
- SQLite FTS5 can handle ~10,000 inserts/sec → ~5 seconds for FTS
- JSONL parsing likely slower (depends on message size)
- Consider batch inserts (transaction per conversation)

**Integration Point:**
- Start indexer in `cmd/proxy/main.go` after storage initialization
- Pass storage service to indexer
- Defer indexer.Stop() for clean shutdown

**Files to Create:**
- `proxy/internal/service/indexer.go` - main service
- `proxy/internal/service/indexer_test.go` - unit tests
- `proxy/internal/service/indexer_integration_test.go` - file watcher tests

**Files to Modify:**
- `proxy/go.mod` - add fsnotify dependency
- `proxy/cmd/proxy/main.go` - start/stop indexer
- `proxy/internal/service/storage.go` - add interface methods for indexing
- `proxy/internal/service/storage_sqlite.go` - implement interface methods

**Risks:**
- fsnotify can miss events under heavy load → add health check
- Recursive watching may fail on some systems → test on macOS, Linux
- Large directories (1000+ files) may hit OS limits → consider batching
- JSONL files can be huge (100MB+) → stream parsing, don't load entire file

---

## [P2] Search API Endpoint with Pagination

**Status**: Not Started
**Effort**: Medium (6-8 hours)
**Dependencies**: P0 (schema), P1 (indexed data)
**Spec Reference**: ROADMAP.md Phase 1 conversation-search-indexing • **Status Reference**: STATUS-20251227_233000.md §What's Missing (CRITICAL GAPS) #4

### Description
Expose the FTS5 search capability via HTTP API. Provide paginated results with metadata to enable frontend integration. Keep response format simple (no snippet extraction for MVP).

**Why This is P2:**
- Requires indexed data from P1 to be useful
- Frontend already has client-side search (this is enhancement)
- Simpler than P1 (mostly plumbing)

**What Exists:**
- ✅ Handler pattern in `handlers.go`
- ✅ Router setup in `main.go`
- ✅ Frontend API proxy in `web/app/routes/api.conversations.tsx`

**What's Missing:**
- Search handler in `handlers.go`
- Search method in storage interface
- FTS5 query execution in `storage_sqlite.go`
- Route registration in `main.go`
- Frontend API route (new file: `api.conversations.search.tsx`)

### Acceptance Criteria

- [ ] **Endpoint Exists**: `GET /api/conversations/search?q=<query>&limit=50&offset=0` returns 200 with valid JSON
- [ ] **Search Works**: Query "authentication" returns conversations containing that term (case-insensitive)
- [ ] **Multi-term Search**: Query "auth bug" uses OR logic (matches "auth" OR "bug")
- [ ] **Pagination Functional**: limit=20&offset=20 returns second page of 20 results
- [ ] **Response Format**: Returns `{query, results: [{conversationId, projectName, matchCount, lastActivity}], total}`
- [ ] **Empty Query Handled**: Empty or missing `q` parameter returns 400 Bad Request
- [ ] **No Results Graceful**: Query with zero matches returns 200 with empty results array

### Technical Notes

**API Design:**
```
GET /api/conversations/search?q=<query>&limit=<n>&offset=<m>&project=<path>

Query Parameters:
- q (required): Search query string
- limit (optional, default 50): Max results per page
- offset (optional, default 0): Pagination offset
- project (optional): Filter by project path

Response:
{
  "query": "authentication bug",
  "results": [
    {
      "conversationId": "agent-abc123",
      "projectName": "auth-service",
      "projectPath": "/Users/bmf/.claude/projects/auth-service",
      "matchCount": 5,
      "lastActivity": "2025-12-27T10:30:00Z"
    }
  ],
  "total": 15,
  "limit": 50,
  "offset": 0
}
```

**FTS5 Query:**
```sql
-- Find conversations matching query
SELECT
    c.id AS conversationId,
    c.project_name AS projectName,
    c.project_path AS projectPath,
    c.end_time AS lastActivity,
    COUNT(f.rowid) AS matchCount
FROM conversations_fts f
JOIN conversations c ON f.conversation_id = c.id
WHERE conversations_fts MATCH ?  -- FTS5 query (e.g., 'auth OR bug')
GROUP BY c.id
ORDER BY matchCount DESC, c.end_time DESC
LIMIT ? OFFSET ?
```

**FTS5 Query Syntax:**
- User query: "authentication bug"
- Convert to FTS5: "authentication OR bug" (multi-term OR logic)
- Escape special chars: quotes, parentheses
- Do NOT expose raw FTS5 syntax to users (security risk)

**Storage Interface Extension:**
```go
// In proxy/internal/service/storage.go
type SearchOptions struct {
    Query       string
    ProjectPath string
    Limit       int
    Offset      int
}

type SearchResults struct {
    Query   string
    Results []*ConversationMatch
    Total   int
    Limit   int
    Offset  int
}

type ConversationMatch struct {
    ConversationID string
    ProjectName    string
    ProjectPath    string
    MatchCount     int
    LastActivity   time.Time
}

type StorageService interface {
    // ... existing methods ...
    SearchConversations(opts SearchOptions) (*SearchResults, error)
}
```

**Handler Implementation:**
```go
// In proxy/internal/handler/handlers.go
func (h *Handler) SearchConversations(w http.ResponseWriter, r *http.Request) {
    query := r.URL.Query().Get("q")
    if query == "" {
        writeErrorResponse(w, "Query parameter 'q' required", http.StatusBadRequest)
        return
    }

    limit := 50
    if l := r.URL.Query().Get("limit"); l != "" {
        if parsed, err := strconv.Atoi(l); err == nil && parsed > 0 {
            limit = parsed
        }
    }

    offset := 0
    if o := r.URL.Query().Get("offset"); o != "" {
        if parsed, err := strconv.Atoi(o); err == nil && parsed >= 0 {
            offset = parsed
        }
    }

    opts := service.SearchOptions{
        Query:       query,
        ProjectPath: r.URL.Query().Get("project"),
        Limit:       limit,
        Offset:      offset,
    }

    results, err := h.storageService.SearchConversations(opts)
    if err != nil {
        writeErrorResponse(w, "Search failed", http.StatusInternalServerError)
        return
    }

    writeJSONResponse(w, results, http.StatusOK)
}
```

**Frontend Integration (Bonus - not required for backend sprint):**
```typescript
// New file: web/app/routes/api.conversations.search.tsx
export const loader: LoaderFunction = async ({ request }) => {
  const url = new URL(request.url);
  const query = url.searchParams.get("q");

  if (!query) {
    return json({ error: "Query required" }, { status: 400 });
  }

  const backendUrl = new URL('http://localhost:3001/api/conversations/search');
  backendUrl.searchParams.append('q', query);
  backendUrl.searchParams.append('limit', url.searchParams.get('limit') || '50');
  backendUrl.searchParams.append('offset', url.searchParams.get('offset') || '0');

  const response = await fetch(backendUrl.toString());
  return json(await response.json());
};
```

**Testing Strategy:**
1. Unit test `SearchConversations()` in `storage_sqlite_test.go`:
   - Seed test DB with 3 conversations
   - Run search for known term
   - Verify results contain expected conversationID
   - Test pagination (offset, limit)
   - Test empty results

2. Integration test in `handlers_test.go`:
   - HTTP GET to `/api/conversations/search?q=test`
   - Verify 200 status
   - Verify response JSON structure
   - Test 400 for missing query

**Files to Create:**
- None (all modifications)

**Files to Modify:**
- `proxy/internal/service/storage.go` - add interface methods
- `proxy/internal/service/storage_sqlite.go` - implement search
- `proxy/internal/handler/handlers.go` - add handler
- `proxy/cmd/proxy/main.go` - register route
- `proxy/internal/service/storage_sqlite_test.go` - add tests
- `proxy/internal/handler/handlers_test.go` - add endpoint test

**Risks:**
- FTS5 query injection if user input not sanitized → parameterize queries
- Large result sets (1000+ matches) could slow response → enforce max limit (e.g., 200)
- Project filter may not use index → test query plan with EXPLAIN QUERY PLAN

---

## Dependency Graph

```
P0: Database Schema & Parser
    ↓
P1: Indexing Service (depends on P0 schema + parser)
    ↓
P2: Search API (depends on P1 indexed data)
```

**Critical Path:** P0 → P1 → P2 (fully sequential)

**Parallelization Opportunities:** None (each blocks the next)

---

## Recommended Implementation Sequence

### Phase 1: Foundation (8-12 hours)
1. Research JSONL message format (2-3 hours)
   - Load 10+ real files from `~/.claude/projects/`
   - Document all message types
   - Create test fixtures
2. Design and create database schema (1 hour)
   - Write migration script
   - Test migration on dev DB
3. Implement message parser (3-4 hours)
   - Write content extractor
   - Write tool name extractor
   - Comprehensive unit tests (5+ fixtures)
4. Verify P0 acceptance criteria (1 hour)

### Phase 2: Indexing Service (10-14 hours)
5. Add fsnotify dependency (0.5 hours)
6. Create ConversationIndexer service structure (2 hours)
7. Implement initial indexing (walk + parse) (3 hours)
8. Implement file watcher with debouncing (4 hours)
9. Add error recovery and health checks (2 hours)
10. Integration tests (file watcher scenarios) (2 hours)
11. Wire up in main.go (0.5 hours)
12. Verify P1 acceptance criteria (1 hour)

### Phase 3: Search API (6-8 hours)
13. Extend storage interface (0.5 hours)
14. Implement FTS5 search query (2 hours)
15. Write search handler (1 hour)
16. Register route in main.go (0.5 hours)
17. Unit tests for search (2 hours)
18. Integration test for endpoint (1 hour)
19. Verify P2 acceptance criteria (1 hour)

### Phase 4: Validation (2-4 hours)
20. End-to-end test (index → search → results)
21. Performance benchmark (1000+ conversations)
22. Manual testing with real data
23. Documentation updates

**Total Estimated Effort:** 26-38 hours

---

## Risk Assessment

### High Risk Items
1. **JSONL Message Format Unknown** (P0)
   - **Impact:** Cannot parse messages, indexing fails completely
   - **Mitigation:** Reverse engineer from real files, create comprehensive test suite
   - **Contingency:** If too many variants, index only common types, log unknowns

2. **Initial Indexing Performance** (P1)
   - **Impact:** 1000+ conversations could take minutes, slow startup
   - **Mitigation:** Benchmark early, consider background indexing
   - **Contingency:** Add manual trigger button in UI if auto-index too slow

### Medium Risk Items
3. **File Watcher Reliability** (P1)
   - **Impact:** Missed events = stale index
   - **Mitigation:** Add staleness detection, periodic re-index task
   - **Contingency:** Manual "Rebuild Index" button in UI

4. **FTS5 Query Performance** (P2)
   - **Impact:** Slow queries on large datasets
   - **Mitigation:** Use EXPLAIN QUERY PLAN, add indexes as needed
   - **Contingency:** Add result limit caps, consider pagination-only searches

### Low Risk Items
5. **FTS5 Query Injection** (P2)
   - **Impact:** Security vulnerability if user input not sanitized
   - **Mitigation:** Parameterized queries, escape special chars
   - **Contingency:** Validate and sanitize all user input

---

## Success Metrics

### Functional Metrics
- [ ] Can search 1000+ conversations in <500ms
- [ ] Index stays synchronized with JSONL changes (within 5 seconds)
- [ ] Search results match expectations (manual verification)
- [ ] Zero crashes during 24-hour test run

### Performance Metrics
- [ ] Initial indexing: <1 second per 100 conversations
- [ ] Search query: <200ms for typical query
- [ ] Incremental update: <100ms per conversation
- [ ] Memory usage: <50MB additional for indexer service

### Quality Metrics
- [ ] All acceptance criteria met (21 criteria total)
- [ ] Test coverage >80% for new code
- [ ] Zero high-severity issues in code review
- [ ] Documentation complete (README, API docs)

---

## Open Questions & Ambiguities

### Resolved (User Confirmed)
✅ **Indexing trigger:** Auto-index on startup
✅ **Search scope:** Message text + tool names only (skip tool results)
✅ **Debounce delay:** 5 seconds
✅ **Pagination:** 50 results per page

### Remaining (Can Decide During Implementation)
- **Snippet extraction:** Defer to future sprint (too complex for MVP)
- **Relevance ranking:** Use FTS5 default BM25 (can tune later)
- **Index staleness UI:** Add indicator in future sprint

---

## Handoff Notes for Implementer

### Before You Start
1. Read STATUS-20251227_233000.md §What Exists to understand current state
2. Review existing code:
   - `proxy/internal/service/conversation.go` - conversation loading
   - `proxy/internal/service/storage_sqlite.go` - migration pattern
3. Load real JSONL files to understand message format (CRITICAL)

### During Implementation
1. Start with P0 (schema + parser) - verify with tests before moving on
2. Keep parser separate from indexing logic (easier to test)
3. Use transactions for batch inserts (performance)
4. Log generously (indexing progress, errors, timing)

### Testing Strategy
1. Unit tests first (parser, search query)
2. Integration tests second (file watcher, endpoint)
3. Manual testing with real data last (performance, correctness)

### Gotchas
- JSONL files can be 100MB+ (don't load entire file into memory)
- Message.Message is json.RawMessage (must Unmarshal type-specifically)
- fsnotify can fail silently (add health check)
- FTS5 queries need escaping (security risk)

### When to Ask Questions
- If message format has >5 unknown types
- If initial indexing takes >5 minutes for 1000 conversations
- If file watcher fails to detect changes in testing
- If FTS5 queries take >1 second

---

## Definition of Done

See separate file: `DOD-2025-12-27-232852.md`
