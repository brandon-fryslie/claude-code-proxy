# Definition of Done: Proxy-Core Extraction Sprint

**Sprint**: Monorepo Restructure Phase 1
**Objective**: Extract proxy-core into standalone Go module
**Status**: All criteria must be satisfied before marking sprint complete

---

## Build & Compilation (MUST PASS)

- [ ] **B1**: `just build` compiles proxy-core binary with zero errors
  - Verification: `ls -l bin/proxy-core && file bin/proxy-core | grep executable`

- [ ] **B2**: `go mod tidy` passes in both proxy-core/ and proxy/
  - Verification: No conflicts, no missing deps
  - Command: `cd proxy-core && go mod tidy && cd ../proxy && go mod tidy`

- [ ] **B3**: go.mod replacement directive works correctly
  - Verification: `go mod graph | grep proxy-core` shows exactly 1 edge
  - No circular dependencies

---

## Testing (MUST PASS)

- [ ] **T1**: Unit tests pass in proxy-core/
  - Command: `cd proxy-core && go test -tags "fts5" ./... -v`
  - All tests green, no skips

- [ ] **T2**: Unit tests pass in proxy/
  - Command: `cd proxy && go test -tags "fts5" ./... -v`
  - Verifies proxy-data can import from proxy-core

- [ ] **T3**: Integration tests verify core handlers work
  - Command: Run core handler tests
  - Verify startup sequence: config → provider → handler → server

---

## Functionality (MUST WORK)

- [ ] **F1**: proxy-core binary starts without errors
  - Command: `./bin/proxy-core &`
  - Output shows: "server running on http://localhost:8001"
  - No panic or fatal errors

- [ ] **F2**: Health endpoint responds
  - Command: `curl -s http://localhost:8001/health | jq .`
  - HTTP 200 status code
  - Valid JSON response

- [ ] **F3**: Core API endpoints work
  - Command: `curl -s http://localhost:8001/v1/models | head -c 100`
  - Returns valid response (not 404)

- [ ] **F4**: Configuration loading works
  - Verify: proxy-core reads config.yaml from current directory
  - Verify: Environment variables override config values

---

## Docker (MUST WORK)

- [ ] **D1**: docker/Dockerfile.proxy-core builds successfully
  - Command: `podman build -f docker/Dockerfile.proxy-core -t proxy-core-test .`
  - Output: "Successfully built" message

- [ ] **D2**: Docker image runs and responds
  - Start: `podman run -d -p 8001:8001 proxy-core-test`
  - Test: `curl http://localhost:8001/health`
  - HTTP 200, valid JSON

- [ ] **D3**: Volume mounts work
  - Config: `-v ./config.yaml:/app/config.yaml:ro`
  - Database: `-v ./data:/app/data`
  - Both paths accessible in container

- [ ] **D4**: Image size is reasonable
  - Command: `podman images proxy-core-test`
  - Size should be < 100MB (Alpine + binary + deps)

---

## Code Quality (MUST PASS)

- [ ] **Q1**: No linting errors in proxy-core/
  - Command: `cd proxy-core && golangci-lint run ./...` (if configured)
  - Or: `cd proxy-core && go vet ./...`

- [ ] **Q2**: Code follows existing patterns
  - Verify: config, handler, provider packages match original patterns
  - Verify: Comment style and naming conventions consistent

- [ ] **Q3**: No unused imports or dead code
  - Command: `go mod tidy` changes nothing after initial setup
  - All imports are used

---

## Documentation (MUST BE UPDATED)

- [ ] **D1**: CLAUDE.md updated with monorepo structure
  - Section "Architecture" describes proxy-core as separate module
  - Section "Build System" explains go.mod replacement pattern

- [ ] **D2**: README.md has updated architecture diagram
  - Shows proxy-core/ as separate directory
  - Shows go.mod replacement relationship with proxy/

- [ ] **D3**: Comments in go.mod explain replacement directive
  - go.mod has comment explaining why replacement is used
  - Documents pattern for Phase 2 (proxy-data)

---

## Git History (MUST BE CLEAN)

- [ ] **G1**: Commits are logical and atomic
  - 1 commit: Directory setup
  - 1 commit: go.mod creation and updates
  - 1 commit: Justfile changes
  - 1 commit: Docker updates
  - 1 commit: Documentation
  - (5-6 commits total, each independently buildable)

- [ ] **G2**: Commit messages follow pattern
  - Format: `refactor(module): description`
  - Example: `refactor(proxy-core): extract into standalone module`

- [ ] **G3**: No force-pushes, clean linear history
  - Command: `git log --oneline` shows clean progression
  - No "fixup" or "WIP" commits

---

## Integration & Smoke Tests (MUST WORK)

- [ ] **I1**: Zero-downtime deployment scenario works
  - Start all services: `podman-compose up -d`
  - Rebuild just proxy-core: `podman-compose up -d --no-deps --build proxy-core`
  - Verify proxy-data still works: `curl http://localhost:8000/api/stats`
  - All services healthy

- [ ] **I2**: Full stack builds and runs
  - Commands:
    ```bash
    just clean
    just build
    just test
    just docker
    ```
  - All complete without errors
  - `podman-compose ps` shows no "unhealthy" services

- [ ] **I3**: Hot reload scenario works
  - Edit source in proxy-core/internal/
  - Run `just build`
  - Only proxy-core binary rebuilds (not proxy-data)
  - Verify binary is newer: `ls -l bin/proxy-{core,data}`

---

## Sign-Off Checklist

Before marking sprint complete:

- [ ] All acceptance criteria above have green checkmarks
- [ ] Tests run locally AND would pass in CI
- [ ] Docker images build and run
- [ ] Documentation is reviewed and accurate
- [ ] Commits are pushed to branch (not merged yet)
- [ ] No merge conflicts with main branch
- [ ] Performance: No regressions in startup time

---

## Notes for Implementation

- Acceptance criteria are binary: all must pass, no exceptions
- Testing is integral to completion, not separate
- Documentation updates are required, not optional
- Commits must be atomic (you must be able to revert one commit without breaking the build)
- If ANY criterion fails, the entire sprint is not complete - identify the blocking issue and resolve

---
